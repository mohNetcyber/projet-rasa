version: "3.1"
session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true
intents:
  - greet
  - goodbye
  # Transmission (Chap 1 + Chap 3)
  - decrire_probleme
  - demander_supports_transmission
  - demander_caracteristiques_support
  - demander_pertes_transmission
  - demander_affaiblissement
  - comparer_supports
  - demander_bande_passante
  - demander_impédance
  - demander_crosstalk
  - demander_diaphonie
  - demander_adaptation_impédance
  - demander_adsl
  - demander_modulation
  - demander_debit
  - demander_latence
  - demander_fibre
  - demander_equipement
  - demander_paire_torsadee
  - demander_cable_coaxial
  - demander_bruit
  - demander_distorsion
  - demander_bande_frequence
  - demander_type_bruit
  - demander_type_distorsion
  - demander_categorie_paire_torsadee
  - demander_avantage_fibre
  - demander_frequence_porteuse
  # Technologies (Chap 3)
  - demander_vdsl
  - demander_xdsl
  - demander_cable
  - demander_ethernet
  - demander_pon
  - demander_fibre_channel
  - demander_infiniband
  - demander_sonet_sdh
  - demander_otn
  # Sans-fil (Chap 3)
  - demander_wifi
  - demander_5g
  - demander_bluetooth
  - demander_lora
  - demander_nfc
  - demander_rfid
  - demander_zigbee
  - demander_z-wave
  - demander_sigfox
  - demander_wimax
  # Protocoles (Chap 1 + Chap 3)
  - demander_protocole
  - demander_http_https
  - demander_dns
  - demander_dhcp
  - demander_voip
  - demander_ftp_sftp
  - demander_smtp
  - demander_imap_pop3
  - demander_bgp
  - demander_ospf
  - demander_rip
  - demander_icmp
  - demander_arp
  # Data Link Layer (Chap 2)
  - demander_protocole_liaison
  - demander_hdlc
  - demander_ppp
  - demander_acquittement
  - demander_controle_flux
  - demander_trame
  - demander_erreur
  - demander_fenetre
  - demander_trame_information
  - demander_trame_supervision
  - demander_trame_non_numerotee
  - demander_bit_stuffing
  - demander_mode_connexion_hdlc
  - demander_controle_erreur_crc
  - demander_controle_erreur_vrc
  - demander_controle_erreur_lrc
  - demander_piggy_backing
  - demander_lcp_ppp
  - demander_ncp_ppp
  # Sécurité (Chap 3)
  - demander_securite
  - demander_chiffrement
  - demander_vpn
  - demander_firewall
  - demander_ids_ips
  - demander_zero_trust
  - demander_pki
  - demander_ssl_tls
  - demander_kerberos
  - demander_radius
  - demander_tacacs
  - demander_802.1x
  # Cloud (Chap 3)
  - demander_cloud
  - demander_iaas
  - demander_paas
  - demander_saas
  - demander_serverless
  - demander_edge
  - demander_fog
  - demander_multicloud
  - demander_hybrid_cloud
  - demander_cloud_natif
  # Opérations (Chap 3)
  - demander_qos
  - demander_monitoring
  - demander_snmp
  - demander_troubleshooting
  - demander_automatisation
  - demander_sdn
  - demander_nfv
  - demander_netconf
  - demander_restconf
  - demander_ansible
  - demander_chef
  - demander_puppet
  # Théorie (Chap 3)
  - demander_subnetting
  - demander_nat
  - demander_vlan
  - demander_mpls
  - demander_mac_adressage
  - demander_routage
  - demander_commutation
  - demander_q_in_q
  - demander_vxlan
  - demander_geneve
  # CHapitres 4, 5 et 6
  - ask_architecture_couches
  - ask_modele_osi
  - ask_tcp_ip
  - ask_normalisation
  - ask_encapsulation
  - ask_primitives
  - ask_lan_vs_wan
  - ask_exercices
  - nlu_fallback
  - ask_ip_addressing
  - ask_subnetting
  - ask_cidr
  - ask_mac_ip_mapping
  - ask_fragmentation
  - ask_interconnection_devices
  - ask_icmp_tools
  - ask_frame_decoding
  - ask_ipv6
  - ask_ip_service
  - ask_datagram_format
  - ask_icmp_protocol
  - ask_exercise_1_principles
  - ask_exercise_2_classes
  - ask_exercise_3_config
  - ask_exercise_4_mac_ip
  - ask_exercise_5_mapping
  - ask_exercise_6_subnets
  - ask_exercise_7_address_plan
  - ask_exercise_8_specific_plan
  - ask_exercise_9_subnet_plan
  - ask_exercise_10_cidr
  - ask_exercise_11_fragmentation
  - ask_exercise_12_interconnection
  - ask_exercise_13_devices
  - ask_exercise_14_ping
  - ask_exercise_15_traceroute
  - ask_exercise_16_datagram
  - ask_exercise_17_ethernet
  - ask_exercise_18_ethernet_arp
  - ask_exercice_1
  - ask_exercice_2
  - ask_exercice_3
  - ask_exercice_4
  - ask_exercice_5
  - ask_exercice_6
  - ask_exercice_7
  - ask_exercice_8
  # Chapitres 6, 7 et 8
  - ask_transport_protocol
  - ask_port
  - ask_list_ports
  - ask_socket
  - ask_checksum
  - ask_tcp_overview
  - ask_bout_en_bout
  - ask_tcp_comparatif_data_link_table
  - ask_tcp_vs_ppp_example
  - ask_tcp_features
  - ask_cycle_connexion_tcp
  - ask_tcp_segment_format
  - connexion_tcp
  - fermeture_tcp
  - etats_tcp
  - temporisation_tcp
  - algorithmes_tcp
  - ask_algorithm_jacobson
  - ask_algorithm_karn
  - ask_autres_temporisateurs_tcp
  - ask_algorithm_clark_nagle
  - ask_controle_congestion_tcp
  - interface_tcp_application
  - ask_primitive
  - primitive_detail
  - udp_intro
  - udp_services
  - udp_header_structure
  - udp_socket_interface
  - udp_vs_tcp
  - udp_use_cases
  - transport_protocols_summary
  - tcp_vs_udp
  - tcp_advantages
  - udp_simplicity
  - tcp_throughput
  - tcp_header_format
  - tcp_connection_context
  - tcp_segment_order
  - tcp_multiple_connections
  - exemple_tcp_multiple_connections
  - tcp_connection_identification
  - tcp_ping_vs_tcp_connection
  - tcp_same_vs_different_networks
  - tcp_netstat_analysis
  - tcp_advanced_statistics
  - decode_tcp_segment
  - ethernet_frame_full_analysis
  - objectifs_du_routage
  - boucles_de_routage
  - panne_et_recalcul
  - protocoles_routage
  - hierarchisation_reseau
  - systeme_autonome
  - difference_igp_egp
  - protocole_rip
  - fonctionnement_rip
  - limites_rip
  - variantes_rip
  - exemple_rip
  - ripv2
  - rip_udp
  - ameliorations_rip
  - protocole_ospf
  - fonctionnement_ospf
  - messages_ospf
  - securite_ospf
  - protocole_bgp
  - fonctionnement_bgp
  - routeur_bgp
  - comparaison_algorithmes
  - diffusion_multicast
  - routage_multicast
  - igmp_gestion_groupes
  - routage_mobilite
  - peer_to_peer
  - types_routage
  - ask_dhcp_definition
  - ask_dhcp_messages
  - ask_dhcp_ports
  - ask_dhcp_use_cases
  - ask_dhcp_fixed_vs_dynamic
  - ask_dhcp_bail
  - ask_dhcp_security
  - expliquer_dns
  - resolution_dns
  - types_enregistrements_dns
  - dns_hierarchique
  - differents_serveurs_dns
  - cache_dns
  - dns_vs_ldap
  - service_ldap
  - relation_dns_annuaire
  - definition_messagerie_electronique
  - fonctionnement_messagerie
  - protocoles_messagerie
  - smtp_details
  - pop3_details
  - imap4_details
  - etiquette_messages
  - liste_diffusion
  - affirm
  - first
entities:
  # Transmission (Chap 1 + Chap 3)
  - symptome
  - support
  - connectique
  - medium
  - equipement
  - interface
  - composant
  - debit
  - latence
  - attenuation
  - bande_passante
  - puissance_signal
  - jitter
  - perte_paquets
  - disponibilite
  - MTBF
  - technologie
  - norme
  - generation
  - modulation
  - codage
  - bruit
  - distorsion
  - bande_frequence
  - type_bruit
  - type_distorsion
  - categorie_paire_torsadee
  - avantage_fibre
  - frequence_porteuse
  # Protocoles (Chap 1 + Chap 3)
  - protocole
  - couche_osi
  - port
  - methode
  - trame
  # Sécurité (Chap 3)
  - algorithme
  - framework
  - menace
  - contre_mesure
  - certificat
  # Cloud (Chap 3)
  - service_cloud
  - modele_deploiement
  - fournisseur
  - ressource_cloud
  # Topologie (Chap 3)
  - architecture
  - topologie
  - schema
  - zone
  # Performance (Chap 3)
  - metrique
  - outil
  - benchmark
  # Virtualisation (Chap 3)
  - hyperviseur
  - technologie_virtuelle
  - orchestration
  # Data Link Layer (Chap 2)
  - type_trame
  - mecanisme
  - erreur
  - taille_fenetre
  - mode_connexion
  - type_erreur
  - sous_protocole_ppp
  - niveau_expertise
  - urgence
  - environnement
  - configuration_qos
  - regles_securite
  - logs_diagnostics
  # Chapitres 4, 5 et 6
  - ip_address
  - subnet_mask
  - cidr
  - mac_address
  - datagram
  - icmp_type
  - network_device
  - ethernet_frame
  - exercise_number
  # Chapitres 7, 8 et 9
  - tcp_flag
  - tcp_field
  - segment_size
  - primitive
  - port_number
slots:
  # Transmission (Chap 1 + Chap 3)
  support:
    type: categorical
    values: ["cuivre", "fibre", "radio", "satellite", "optique libre", "coaxial", "paire torsadée", "multimode", "monomode"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: support
  connectique:
    type: categorical
    values: ["RJ45", "LC", "SC", "ST", "FC", "MPO", "SFP+", "QSFP", "BNC"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: connectique
  medium:
    type: categorical
    values: ["UTP", "STP", "FTP", "SFTP", "OM1", "OM2", "OM3", "OM4", "OS1", "OS2"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: medium
  equipement:
    type: categorical
    values: ["routeur", "switch", "firewall", "serveur", "NAS", "SAN", "modem", "ONT", "OLT", "AP"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: equipement
  interface:
    type: categorical
    values: ["Ethernet", "FastEthernet", "GigabitEthernet", "10GigE", "Serial", "Loopback", "VLAN"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: interface
  composant:
    type: categorical
    values: ["transceiver", "carte réseau", "CPU", "mémoire", "alimentation", "ventilateur"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: composant
  debit:
    type: float
    min_value: 0
    max_value: 1000000
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: debit
  latence:
    type: float
    min_value: 0
    max_value: 1000
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: latence
  attenuation:
    type: float
    min_value: 0
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: attenuation
  bande_passante:
    type: float
    min_value: 0
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: bande_passante
  puissance_signal:
    type: float
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: puissance_signal
  jitter:
    type: float
    min_value: 0
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: jitter
  perte_paquets:
    type: float
    min_value: 0
    max_value: 100
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: perte_paquets
  disponibilite:
    type: float
    min_value: 0
    max_value: 100
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: disponibilite
  MTBF:
    type: float
    min_value: 0
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: MTBF
  technologie:
    type: categorical
    values: ["ADSL", "VDSL", "DOCSIS", "GPON", "Wi-Fi", "5G", "LTE", "Ethernet", "Fibre Channel", "Infiniband"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: technologie
  norme:
    type: categorical
    values: ["IEEE 802.3", "IEEE 802.11", "ITU-T G.992", "RFC 2544", "TIA-568"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: norme
  generation:
    type: categorical
    values: ["1G", "2G", "3G", "4G", "5G", "Wi-Fi 4", "Wi-Fi 5", "Wi-Fi 6", "Wi-Fi 6E"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: generation
  modulation:
    type: categorical
    values: ["QAM", "PSK", "FSK", "OFDM", "DSSS"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: modulation
  codage:
    type: categorical
    values: ["NRZ", "Manchester", "4B5B", "8B10B", "64B66B"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: codage
  bruit:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: bruit
  distorsion:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: distorsion
  bande_frequence:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: bande_frequence
  type_bruit:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: type_bruit
  symptome:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: symptome
  type_distorsion:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: type_distorsion
  categorie_paire_torsadee:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: categorie_paire_torsadee
  avantage_fibre:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: avantage_fibre
  frequence_porteuse:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: frequence_porteuse
  # Protocoles (Chap 1 + Chap 3)
  protocole:
    type: categorical
    values: ["TCP", "UDP", "IP", "HTTP", "HTTPS", "FTP", "SSH", "SNMP", "BGP", "OSPF", "HDLC", "PPP"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: protocole
  couche_osi:
    type: categorical
    values: ["physique", "liaison", "réseau", "transport", "session", "présentation", "application"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: couche_osi
  port:
    type: float
    min_value: 0
    max_value: 65535
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: port
  methode:
    type: categorical
    values: ["CSMA/CD", "CSMA/CA", "TDMA", "FDMA", "CDMA"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: methode
  trame:
    type: categorical
    values: ["Ethernet II", "802.3", "802.11", "HDLC", "PPP"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: trame
  # Sécurité (Chap 3)
  algorithme:
    type: categorical
    values: ["AES", "RSA", "ECDSA", "SHA", "MD5", "3DES", "ChaCha20"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: algorithme
  framework:
    type: categorical
    values: ["NIST", "ISO 27001", "CIS", "PCI DSS", "GDPR"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: framework
  menace:
    type: categorical
    values: ["DDoS", "phishing", "MITM", "zero-day", "ransomware", "APT", "injection"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: menace
  contre_mesure:
    type: categorical
    values: ["firewall", "IDS", "IPS", "SIEM", "DLP", "WAF"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: contre_mesure
  certificat:
    type: categorical
    values: ["DV", "OV", "EV", "wildcard", "SAN"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: certificat
  # Cloud (Chap 3)
  service_cloud:
    type: categorical
    values: ["IaaS", "PaaS", "SaaS", "FaaS", "DBaaS", "CaaS", "NaaS"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: service_cloud
  modele_deploiement:
    type: categorical
    values: ["public", "privé", "hybride", "communautaire", "multicloud"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: modele_deploiement
  fournisseur:
    type: categorical
    values: ["AWS", "Azure", "GCP", "IBM Cloud", "Oracle Cloud", "Alibaba Cloud"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: fournisseur
  ressource_cloud:
    type: categorical
    values: ["VM", "container", "fonction", "stockage objet", "base de données"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: ressource_cloud
  # Topologie (Chap 3)
  architecture:
    type: categorical
    values: ["3-tier", "spine-leaf", "hub-spoke", "full-mesh", "partial-mesh"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: architecture
  topologie:
    type: categorical
    values: ["étoile", "bus", "anneau", "maillée", "arbre", "hybride"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: topologie
  schema:
    type: categorical
    values: ["logique", "physique", "de déploiement", "de sécurité"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: schema
  zone:
    type: categorical
    values: ["DMZ", "LAN", "WAN", "MAN", "SAN", "VPN"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: zone
  # Performance (Chap 3)
  metrique:
    type: categorical
    values: ["throughput", "latency", "jitter", "packet loss", "availability"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: metrique
  outil:
    type: categorical
    values: ["Wireshark", "tcpdump", "iperf", "ping", "traceroute", "NetFlow"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: outil
  benchmark:
    type: categorical
    values: ["RFC 2544", "RFC 6349", "TR-398", "TIA-4959"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: benchmark
  # Virtualisation (Chap 3)
  hyperviseur:
    type: categorical
    values: ["Type 1", "Type 2", "bare-metal", "hosted"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: hyperviseur
  technologie_virtuelle:
    type: categorical
    values: ["VM", "container", "unikernel", "microVM"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: technologie_virtuelle
  orchestration:
    type: categorical
    values: ["Kubernetes", "Docker Swarm", "Mesos", "Nomad"]
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: orchestration
  # Data Link Layer (Chap 2)
  type_trame:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: type_trame
  mecanisme:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: mecanisme
  erreur:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: erreur
  taille_fenetre:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: taille_fenetre
  mode_connexion:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: mode_connexion
  type_erreur:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: type_erreur
  sous_protocole_ppp:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: sous_protocole_ppp
  # Context Slots (Chap 3)
  niveau_expertise:
    type: categorical
    values: ["débutant", "intermédiaire", "expert"]
    initial_value: "intermédiaire"
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: niveau_expertise
  urgence:
    type: categorical
    values: ["faible", "moyenne", "haute", "critique"]
    initial_value: "moyenne"
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: urgence
  environnement:
    type: categorical
    values: ["production", "test", "développement", "laboratoire"]
    initial_value: "production"
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: environnement
  configuration_qos:
    type: list
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: configuration_qos
  regles_securite:
    type: list
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: regles_securite
  logs_diagnostics:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: logs_diagnostics
  # Chaptres 4, 5 et 6
  ip_address:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: ip_address
  subnet_mask:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: subnet_mask
  cidr:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: cidr
  mac_address:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: mac_address
  network_device:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: network_device
  ethernet_frame:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: ethernet_frame
  exercise_number:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: exercise_number
  current_exercise:
    type: text
    influence_conversation: true
    mappings:
      - type: custom
  requested_slot:
    type: any
    mappings:
      - type: custom
  action:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: action
  algorithme_temporisation:
    type: text
    influence_conversation: false
    mappings:
      - type: from_text
  version_rip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_text
  message_type:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: message_type
  ip_type:
    type: categorical
    values:
      - fixe
      - dynamique
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_type
  duration:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: duration
  tcp_flag:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: tcp_flag
  tcp_field:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: tcp_field
  segment_size:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: segment_size
  primitive:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: primitive
  client_ip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_address
  server_ip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_address
  client_port:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: port_number
  server_port:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: port_number
  last_topic:
    type: text
    influence_conversation: true
    initial_value: null
    mappings:
      - type: custom
        action: action_set_last_topic
responses:

  utter_greet:
    - text: Bonjour ! Je suis prêt à répondre à vos questions sur les réseaux, le
        modèle OSI, TCP/IP, ou le protocole IP. Par où commençons-nous ?
    - text: Salut ! Envie de parler réseaux, OSI, TCP/IP ou adressage IP ? Je suis là
        pour ça !
    - text: Hello ! Je peux t'expliquer l'architecture réseau, IP, ou les exercices
        des chapitres. Qu'est-ce qui t'intéresse ?
    - text: Bonsoir ! Prêt à plonger dans les concepts réseau ou les exercices des
        chapitres 4, 5 et 6 ?
    - text: Coucou ! Questions sur les couches OSI, TCP/IP, ou les sous-réseaux ? Je
        t’attends !
    - text: Salutations ! Intéressé par les réseaux, l’adressage IP, ou les exercices
        pratiques ? Dis-moi tout !
    - text: Yo ! Besoin d’aide sur les protocoles réseau, OSI, ou les calculs de
        sous-réseaux ? Je suis prêt !
  utter_goodbye:
    - text: Au revoir ! Revenez si vous avez d’autres questions sur les réseaux.
    - text: Bye ! À bientôt pour plus de discussions sur les réseaux.
    - text: Tchao ! Si besoin, je suis là pour OSI, IP, ou autre.
    - text: Merci, à la prochaine pour parler réseaux ou exercices !
    - text: À plus ! N’hésitez pas à revenir pour des questions réseau.
    - text: Ciao ! Repasse pour des questions sur TCP/IP ou autre !
    - text: À bientôt ! Si les réseaux te posent question, je suis là.
  # Transmission (Chap 1 + Chap 3)
  utter_expliquer_supports_transmission:
    - text: "Les supports de transmission incluent {support}. Ils permettent le transfert des données entre équipements distants. Les supports guidés incluent cuivre (1Gbps max, 100m), fibre (10Gbps+, 100km), coaxial (10Gbps, 500m), tandis que les supports non guidés utilisent des ondes comme radio ou satellite."
    - text: "Comparaison technique des supports:\n| Support | Débit max | Distance | Atténuation | Coût |\n|---------|-----------|----------|-------------|------|\n| Cuivre | 10 Gbps | 100m | 20 dB/100m | €€ |\n| Fibre OM4 | 100 Gbps | 550m | 3 dB/km | €€€€ |\n| Radio 5G | 1 Gbps | 1km | Variable | €€€ |"
  utter_expliquer_caracteristiques_support:
    - text: "Pour {support}, les caractéristiques incluent:\n- Débit max: {debit}\n- Portée: {distance}\n- Atténuation: {attenuation}\n- Coût: {cout}"
  utter_expliquer_pertes_transmission:
    - text: "Les pertes de transmission incluent l'atténuation ({attenuation} dB/km) et les pertes par connectique. Elles dépendent du {support} et de la {bande_frequence}."
  utter_expliquer_affaiblissement:
    - text: "L'{attenuation} mesure la perte de puissance du signal en dB. Par exemple, une fibre optique a une atténuation de ~0.2 dB/km à 1550 nm."
  utter_comparer_supports:
    
    - text: "Comparaison {support1} vs {support2}:\n- Débit: {debit1} vs {debit2}\n- Latence: {latence1} vs {latence2}\n- Portée: {portee1} vs {portee2}"
  utter_expliquer_bande_passante:
    - text: "La bande passante correspond à la capacité d’un câble à transmettre des données. Plus elle est grande, plus le débit est élevé."

  utter_expliquer_impedance:
    - text: "L’impédance est une mesure de la résistance d’un câble au passage du courant alternatif. Elle doit être adaptée pour éviter les réflexions."

  utter_expliquer_crosstalk:
    - text: "Le crosstalk ou diaphonie désigne les interférences entre fils dans un câble, ce qui peut perturber la transmission."

  utter_expliquer_diaphonie:
    - text: "La diaphonie est un bruit parasite causé par un signal dans un câble voisin. Elle peut dégrader la qualité de la communication."

  utter_expliquer_adaptation_impedance:
    - text: "L’adaptation d’impédance permet d’éviter les pertes et les réflexions de signal dans les liaisons électriques."

  utter_expliquer_adsl:
    - text: "L'{technologie} utilise la ligne téléphonique pour transmettre voix et données via modulation DMT. Débits asymétriques: descendant > ascendant."
  utter_expliquer_modulation:
    - text: "La {modulation} modifie un signal porteur (amplitude, fréquence, phase) pour transporter des données. Ex.: QAM dans ADSL."
  utter_expliquer_debit:
    - text: "Le {debit} mesure les données transmises par seconde (bps). Dépend du {support}, {modulation}, et perturbations ({bruit}, {distorsion})."
  utter_expliquer_latence:
    - text: "La {latence} est le temps de transit d’un signal ({latence} ms). Influencée par distance, {support}, et équipements."
  utter_expliquer_fibre:
    - text: "La fibre optique utilise la lumière pour transmettre des données, offrant un {debit} élevé, faible {latence}, et résistance aux interférences."
  utter_expliquer_equipement:
    - text: "L'{equipement} (ex.: {routeur}, {switch}) gère la transmission, réception, ou gestion des données dans un réseau."
  utter_expliquer_paire_torsadee:
    - text: "La {paire_torsadee} (ex.: UTP) minimise les interférences par torsadage. Utilisée dans réseaux locaux ({categorie_paire_torsadee})."
  utter_expliquer_cable_coaxial:
    - text: "Le {cable_coaxial} offre protection contre perturbations, utilisé pour hautes fréquences (ex.: TV par câble)."
  utter_expliquer_bruit:
    - text: "Le {bruit} (ex.: diaphonie, parasites) perturbe le signal. Fibres moins sensibles que {paire_torsadee} ou {cable_coaxial}."
  utter_expliquer_distorsion:
    - text: "La {distorsion} altère le signal selon la fréquence, compliquant la réception. Dépend du {support}."
  utter_expliquer_bande_frequence:
    - text: "La {bande_frequence} (ex.: 87,5-108 MHz pour FM) est la plage de fréquences utilisée pour la transmission."
  utter_expliquer_type_bruit:
    - text: "Types de {type_bruit}: diaphonie (signaux voisins), bruit thermique (électrons), parasites (sources externes)."
  utter_expliquer_type_distorsion:
    - text: "Types de {type_distorsion}: amplitude (intensité), phase (synchronisme). Affecte la réception."
  utter_expliquer_categorie_paire_torsadee:
    - text: "{categorie_paire_torsadee}: Cat5 (100 Mbps), Cat6 (10 Gbps, courtes distances), meilleure résistance aux interférences."
  utter_expliquer_avantage_fibre:
    - text: "Avantages de la fibre: grande {bande_passante}, faible atténuation, immunité aux interférences, sécurité."
  utter_expliquer_frequence_porteuse:
    - text: "La {frequence_porteuse} transporte les données via modulation. Ex.: utilisée dans {modulation} pour réseaux sans fil."
  # Technologies (Chap 3)
  utter_expliquer_vdsl:
    - text: "VDSL ({technologie}) offre des débits plus élevés que ADSL via une modulation DMT sur cuivre, mais sur des distances plus courtes."
  utter_expliquer_xdsl:
    - text: "xDSL regroupe les technologies DSL (ADSL, VDSL) utilisant des lignes téléphoniques pour un accès Internet à haut débit."
  utter_expliquer_cable:
    - text: "Les connexions par câble ({technologie}) utilisent des câbles coaxiaux via DOCSIS, offrant des débits élevés (jusqu’à 10 Gbps)."
  utter_expliquer_ethernet:
    - text: "Ethernet ({technologie}) est une norme LAN (IEEE 802.3) pour réseaux filaires, supportant des débits de 10 Mbps à 400 Gbps."
  utter_expliquer_pon:
    - text: "PON (Passive Optical Network) utilise la fibre optique pour distribuer des données sans équipements actifs intermédiaires."
  utter_expliquer_fibre_channel:
    - text: "Fibre Channel est une technologie de stockage à haute vitesse, souvent utilisée dans les réseaux SAN."
  utter_expliquer_infiniband:
    - text: "Infiniband offre une connectivité à faible latence et haut débit pour les supercalculateurs et réseaux de stockage."
  utter_expliquer_sonet_sdh:
    - text: "SONET/SDH sont des protocoles pour réseaux optiques synchrones, utilisés pour les télécommunications longue distance."
  utter_expliquer_otn:
    - text: "OTN (Optical Transport Network) transporte des données sur fibre avec une gestion avancée des longueurs d’onde."
  # Sans-fil (Chap 3)
  utter_expliquer_wifi:
    - text: "Wi-Fi ({technologie}, IEEE 802.11) utilise des fréquences (2.4 GHz, 5 GHz) pour des réseaux sans fil locaux."
  utter_expliquer_5g:
    - text: "5G ({technologie}) offre des débits jusqu’à 10 Gbps, faible {latence}, et supporte IoT à grande échelle."
  utter_expliquer_bluetooth:
    - text: "Bluetooth utilise la bande 2.4 GHz pour des connexions sans fil à courte portée (ex.: écouteurs, capteurs)."
  utter_expliquer_lora:
    - text: "LoRa est une technologie sans fil longue portée à faible consommation, idéale pour l’IoT."
  utter_expliquer_nfc:
    - text: "NFC (Near Field Communication) permet des communications sans fil à très courte portée (paiements, tags)."
  utter_expliquer_rfid:
    - text: "RFID utilise des ondes radio pour identifier et suivre des objets à distance (ex.: logistique)."
  utter_expliquer_zigbee:
    - text: "Zigbee est un protocole sans fil à faible consommation pour réseaux maillés (ex.: domotique)."
  utter_expliquer_z-wave:
    - text: "Z-Wave est similaire à Zigbee, optimisé pour la domotique avec une portée d’environ 100m."
  utter_expliquer_sigfox:
    - text: "Sigfox est une technologie LPWAN pour IoT, avec une portée étendue et faible consommation."
  utter_expliquer_wimax:
    - text: "WiMAX (IEEE 802.16) fournit un accès sans fil à large bande, concurrençant la 4G dans certains cas."
  # Protocoles (Chap 1 + Chap 3)
  utter_expliquer_protocole:
    - text: "Un {protocole} (ex.: {TCP}, {HTTP}) définit les règles de communication réseau. Ex.: TCP/IP pour Internet."
  utter_expliquer_http_https:
    - text: "HTTP/HTTPS ({protocole}) gère les communications web. HTTPS utilise SSL/TLS pour la sécurité."
  utter_expliquer_dhcp:
    - text: "DHCP ({protocole}) attribue dynamiquement des adresses IP aux appareils dans un réseau."
  utter_expliquer_voip:
    - text: "VoIP ({protocole}) permet des appels vocaux via Internet (ex.: SIP, RTP) avec faible {latence}."
  utter_expliquer_ftp_sftp:
    - text: "FTP/SFTP ({protocole}) transfère des fichiers. SFTP ajoute un chiffrement via SSH."
  utter_expliquer_smtp:
    - text: "SMTP ({protocole}) envoie des emails entre serveurs (port 25 ou 587 pour TLS)."
  utter_expliquer_imap_pop3:
    - text: "IMAP/POP3 ({protocole}) récupèrent les emails. IMAP synchronise, POP3 télécharge."
  utter_expliquer_bgp:
    - text: "BGP ({protocole}) gère le routage inter-domaines sur Internet, utilisé par les FAI."
  utter_expliquer_ospf:
    - text: "OSPF ({protocole}) est un protocole de routage interne basé sur l’état des liens."
  utter_expliquer_rip:
    - text: "RIP ({protocole}) est un protocole de routage à vecteur de distance, simple mais limité."
  utter_expliquer_icmp:
    - text: "ICMP ({protocole}) gère les diagnostics réseau (ex.: ping, traceroute)."
  utter_expliquer_arp:
    - text: "ARP ({protocole}) mappe les adresses IP aux adresses MAC dans un réseau local."
  # Data Link Layer (Chap 2)
  utter_expliquer_protocole_liaison:
    - text: "Les protocoles de liaison (ex.: {protocole}) opèrent à la couche 2 OSI, assurant une transmission fiable via trames, acquittements, et contrôle de flux. Ex.: HDLC utilise des trames I/S/U."
  utter_expliquer_hdlc:
    - text: "HDLC ({protocole}) structure les données en trames avec fanion (01111110), bit stuffing, et supporte NRM/ABM modes. Utilisé dans WAN."
  utter_expliquer_ppp:
    - text: "PPP ({protocole}) est un protocole point-à-point pour Internet/VPN, avec LCP pour liaison et NCP pour réseau (ex.: IPCP)."
  utter_expliquer_acquittement:
    - text: "Les {acquittement} (ex.: RR, RNR) confirment la réception des trames. Piggy-backing intègre les acquittements dans les données."
  utter_expliquer_controle_flux:
    - text: "Le {mecanisme} contrôle de flux (ex.: fenêtre d’anticipation) ajuste le débit pour éviter la surcharge. Ex.: RNR suspend l’envoi."
  utter_expliquer_trame:
    - text: "Une {type_trame} (ex.: I, S, U) inclut fanion, adresse, contrôle, données, et FCS pour détection d’erreurs via CRC."
  utter_expliquer_erreur:
    - text: "Les {erreur} sont détectées via CRC, VRC, ou LRC. CRC est le plus robuste, utilisant un polynôme pour le FCS."
  utter_expliquer_fenetre:
    - text: "La {taille_fenetre} limite les trames non acquittées (ex.: modulo 8). Une grande fenêtre augmente le débit mais complique les erreurs."
  utter_expliquer_trame_information:
    - text: "Les trames I ({type_trame}) transportent les données avec numérotation et FCS pour fiabilité."
  utter_expliquer_trame_supervision:
    - text: "Les trames S ({type_trame}, ex.: RR, RNR, REJ) gèrent acquittements et contrôle de flux sans données."
  utter_expliquer_trame_non_numerotee:
    - text: "Les trames U ({type_trame}, ex.: SABM, UA) configurent la liaison sans séquence ni données."
  utter_expliquer_bit_stuffing:
    - text: "Le {mecanisme} bit stuffing insère un 0 après cinq 1 pour éviter la confusion avec le fanion (01111110)."
  utter_expliquer_mode_connexion_hdlc:
    - text: "{mode_connexion} dans HDLC: NRM (maître-esclave), ABM (peer-to-peer), ARM (hybride). Influence la gestion des trames."
  utter_expliquer_controle_erreur_crc:
    - text: "CRC ({type_erreur}) utilise un polynôme (ex.: CRC-16) pour détecter les erreurs via FCS, fiable pour erreurs en rafale."
  utter_expliquer_controle_erreur_vrc:
    - text: "VRC ({type_erreur}) ajoute un bit de parité par octet, simple mais limité aux erreurs d’un bit."
  utter_expliquer_controle_erreur_lrc:
    - text: "LRC ({type_erreur}) calcule un octet de parité via XOR, efficace pour erreurs en rafale mais moins que CRC."
  utter_expliquer_piggy_backing:
    - text: "Le {mecanisme} piggy-backing intègre les acquittements dans les trames de données, optimisant la bande passante."
  utter_expliquer_lcp_ppp:
    - text: "LCP ({sous_protocole_ppp}) établit/configurait/teste la liaison PPP (ex.: authentification via PAP/CHAP)."
  utter_expliquer_ncp_ppp:
    - text: "NCP ({sous_protocole_ppp}) configure les protocoles réseau (ex.: IPCP pour IP) dans PPP."
  # Sécurité (Chap 3)
  utter_expliquer_securite:
    - text: "La sécurité réseau protège contre les {menace} (ex.: DDoS) via {contre_mesure} (ex.: firewall, IDS)."
  utter_expliquer_chiffrement:
    - text: "Le chiffrement ({algorithme}, ex.: AES) sécurise les données en les rendant illisibles sans clé."
  utter_expliquer_vpn:
    - text: "Un VPN utilise des tunnels chiffrés (ex.: IPsec, SSL) pour sécuriser les communications sur Internet."
  utter_expliquer_firewall:
    - text: "Un {contre_mesure} firewall filtre le trafic réseau selon des règles de sécurité."
  utter_expliquer_ids_ips:
    - text: "IDS/IPS ({contre_mesure}) détecte (IDS) ou bloque (IPS) les menaces en temps réel."
  utter_expliquer_zero_trust:
    - text: "Zero Trust impose une vérification stricte pour chaque accès, indépendamment de la source."
  utter_expliquer_pki:
    - text: "PKI gère les {certificat} (ex.: DV, EV) pour authentification et chiffrement."
  utter_expliquer_ssl_tls:
    - text: "SSL/TLS ({protocole}) sécurise les communications (ex.: HTTPS) via chiffrement et certificats."
  utter_expliquer_kerberos:
    - text: "Kerberos ({protocole}) authentifie les utilisateurs dans un réseau via des tickets sécurisés."
  utter_expliquer_radius:
    - text: "RADIUS ({protocole}) centralise l’authentification et l’autorisation pour l’accès réseau."
  utter_expliquer_tacacs:
    - text: "TACACS+ ({protocole}) sépare authentification, autorisation, et comptabilité pour les équipements."
  utter_expliquer_802.1x:
    - text: "802.1X ({protocole}) authentifie les appareils avant l’accès au réseau (ex.: via EAP)."
  # Cloud (Chap 3)
  utter_expliquer_cloud:
    - text: "Le cloud ({service_cloud}, ex.: IaaS, SaaS) fournit des ressources via {fournisseur} (ex.: AWS)."
  utter_expliquer_iaas:
    - text: "IaaS ({service_cloud}) fournit des infrastructures (VM, stockage) gérées par {fournisseur}."
  utter_expliquer_paas:
    - text: "PaaS ({service_cloud}) offre des plateformes pour développer sans gérer l’infrastructure."
  utter_expliquer_saas:
    - text: "SaaS ({service_cloud}) fournit des applications accessibles via Internet (ex.: Google Docs)."
  utter_expliquer_serverless:
    - text: "Serverless ({service_cloud}) exécute des fonctions sans gérer de serveurs (ex.: AWS Lambda)."
  utter_expliquer_edge:
    - text: "Edge computing traite les données près de la source pour réduire la {latence}."
  utter_expliquer_fog:
    - text: "Fog computing étend le cloud près des appareils IoT pour une faible {latence}."
  utter_expliquer_multicloud:
    - text: "Multicloud utilise plusieurs {fournisseur} (ex.: AWS, Azure) pour flexibilité et résilience."
  utter_expliquer_hybrid_cloud:
    - text: "Hybrid cloud combine cloud {modele_deploiement} privé et public pour équilibrer coût/sécurité."
  utter_expliquer_cloud_natif:
    - text: "Cloud natif utilise des microservices, conteneurs, et {orchestration} (ex.: Kubernetes)."
  # Opérations (Chap 3)
  utter_expliquer_qos:
    - text: "QoS ({configuration_qos}) priorise le trafic (ex.: VoIP) pour garantir faible {latence} et {jitter}."
  utter_expliquer_monitoring:
    - text: "Le monitoring utilise des {outil} (ex.: Wireshark) pour surveiller {metrique} comme {latence}."
  utter_expliquer_snmp:
    - text: "SNMP ({protocole}) collecte des données de performance des équipements réseau."
  utter_expliquer_troubleshooting:
    - text: "Troubleshooting analyse {symptome} (ex.: lenteur) sur {equipement} avec {outil} (ex.: ping)."
  utter_expliquer_automatisation:
    - text: "L’automatisation utilise {outil} (ex.: Ansible) pour configurer/gérer les réseaux."
  utter_expliquer_sdn:
    - text: "SDN (Software-Defined Networking) sépare contrôle et transfert pour une gestion centralisée."
  utter_expliquer_nfv:
    - text: "NFV virtualise les fonctions réseau (ex.: firewall) sur {technologie_virtuelle}."
  utter_expliquer_netconf:
    - text: "NETCONF ({protocole}) configure les équipements réseau via XML de manière standardisée."
  utter_expliquer_restconf:
    - text: "RESTCONF ({protocole}) utilise HTTP/JSON pour configurer les réseaux, plus simple que NETCONF."
  utter_expliquer_ansible:
    - text: "Ansible ({outil}) automatise la configuration réseau via playbooks YAML."
  utter_expliquer_chef:
    - text: "Chef ({outil}) gère les configurations réseau via recettes Ruby."
  utter_expliquer_puppet:
    - text: "Puppet ({outil}) automatise les déploiements réseau avec un langage déclaratif."
  # Théorie (Chap 3)
  utter_expliquer_modele_tcpip:
    - text: "Le modèle TCP/IP regroupe les couches en 4: accès réseau, Internet, transport, application."
  utter_expliquer_subnetting:
    - text: "Le subnetting divise un réseau IP en sous-réseaux pour optimiser l’adressage."
  utter_expliquer_nat:
    - text: "NAT traduit les adresses IP privées en publiques pour connecter à Internet."
  utter_expliquer_vlan:
    - text: "VLAN ({interface}) segmente un réseau en sous-réseaux logiques pour sécurité/efficacité."
  utter_expliquer_mpls:
    - text: "MPLS ({technologie}) route les paquets via des étiquettes pour des performances optimales."
  utter_expliquer_mac_adressage:
    - text: "L’adressage MAC identifie les appareils à la couche liaison via adresses 48 bits."
  utter_expliquer_routage:
    - text: "Le routage ({protocole}, ex.: BGP) dirige les paquets entre réseaux."
  utter_expliquer_commutation:
    - text: "La commutation (ex.: {equipement} switch) transfère les trames dans un LAN."
  utter_expliquer_q_in_q:
    - text: "Q-in-Q encapsule des VLAN dans un autre VLAN pour les réseaux de fournisseurs."
  utter_expliquer_vxlan:
    - text: "VXLAN ({technologie}) crée des réseaux virtuels sur IP pour les data centers."
  utter_expliquer_geneve:
    - text: "Geneve ({technologie}) est une encapsulation flexible pour réseaux virtuels."
  # Advanced Responses (Chap 3)
  utter_demander_cloud:
    - text: "Comparaison {technologie1} vs {technologie2}:\n- Débit: {debit1} vs {debit2}\n- Latence: {latence1} vs {latence2}\n- Portée: {portee1} vs {portee2}"
  utter_guide_implementation:
    - text: "Pour implémenter {technologie}:\n1. Prérequis: {prerequis}\n2. Étapes: {etapes}\n3. Tests: {tests}\n4. Optimisation: {optimisation}"
  utter_advanced_networking:
    - text: "Configuration {protocole}:\n- MTU: {mtu}\n- MSS: {mss}\n- RWIN: {rwin}\n- QoS: {qos_params}"
  utter_security_protocols:
    - text: "Protocoles sécurité {couche_osi}:\n- {couche1}: {protocoles1}\n- {couche2}: {protocoles2}\nBest practices: {best_practices}"
  utter_cloud_architecture:
    - text: "Architecture {modele_deploiement} cloud:\n- Composants: {composants}\n- Connectivité: {connectivite}\n- Sécurité: {securite}"
  utter_wireless_optimization:
    - text: "Optimisation {technologie}:\n1. Analyse RF: {analyse_rf}\n2. Plan des canaux: {plan_canaux}\n3. Puissance TX: {puissance}"
  utter_network_automation:
    - text: "Automatisation avec {outil}:\n1. Inventaire: {inventaire}\n2. Templates: {templates}\n3. Workflows: {workflows}"
  # Chapitres 4, 5 et 6
  utter_architecture_couches:
    - text: >
        Une architecture en couches divise un système en sous-systèmes ordonnés
        (ex: modèle OSI).  *Avantages* : modularité, interfaces claires,
        évolutivité, et maintenance simplifiée.  Chaque couche fournit des
        services à la couche supérieure via des interfaces standardisées.
        Source: Chapitre 4, Section 1.1
    - text: >
        L’architecture en couches permet de structurer les protocoles réseau en
        modules indépendants. Chaque couche gère une fonction spécifique (ex:
        routage, transport) et interagit via des interfaces. Cela réduit la
        complexité et facilite les mises à jour. Source: Chapitre 4, Section 1.1
    - text: >
        Les architectures en couches, comme OSI ou TCP/IP, organisent les
        fonctions réseau en niveaux. Par exemple, la couche physique gère les
        bits, tandis que la couche application gère les données utilisateur.
        Cela garantit une séparation claire des responsabilités. Source:
        Chapitre 4, Section 1.1
    - text: >
        Une architecture en couches offre une modularité qui permet de modifier
        une couche sans affecter les autres. Par exemple, changer un protocole
        de transport n’impacte pas la couche physique. C’est essentiel pour
        l’interopérabilité des systèmes. Source: Chapitre 4, Section 1.1
    - text: >
        Les couches réseau permettent une abstraction des tâches complexes. Chaque
        couche encapsule des fonctionnalités spécifiques, comme la gestion des
        erreurs ou le routage. Cela simplifie le développement et la maintenance
        des réseaux. Source: Chapitre 4, Section 1.1
    - text: >
        Une architecture en couches divise les tâches réseau en étapes logiques.
        Par exemple, la couche liaison gère les trames, tandis que la couche
        réseau s’occupe des paquets. Cela améliore la portabilité des
        protocoles. Source: Chapitre 4, Section 1.1
    - text: >
        Les couches réseau réduisent la complexité en isolant les fonctions. Par
        exemple, la couche physique transmet des bits sans se soucier du contenu
        des données. Cela favorise l’évolutivité des réseaux. Source: Chapitre
        4, Section 1.1
  utter_modele_osi:
    - text: >
        *Modèle OSI* (7 couches) : 1) Physique (bits) 2) Liaison (trames) 3)
        Réseau (paquets) 4) Transport (messages) 5) Session 6) Présentation 7)
        Application. Chaque couche fournit des services à la couche supérieure
        via des primitives. Source: Chapitre 4, Section 2.1
    - text: >
        Le modèle OSI, créé par l’ISO, structure les communications réseau en 7
        couches. La couche physique gère les signaux électriques, tandis que
        l’application interagit avec l’utilisateur. Il garantit une
        standardisation universelle. Source: Chapitre 4, Section 2.1
    - text: >
        Dans le modèle OSI, chaque couche a un rôle précis. Par exemple, la couche
        réseau gère le routage des paquets, tandis que la couche session
        maintient les connexions entre applications. C’est un cadre théorique
        pour comprendre les réseaux. Source: Chapitre 4, Section 2.1
    - text: >
        Le modèle OSI est une référence pour décrire les interactions réseau. La
        couche liaison gère les trames, assurant une communication sans erreur
        entre deux nœuds. La couche application, elle, gère les protocoles comme
        HTTP. Source: Chapitre 4, Section 2.1
    - text: >
        OSI divise la communication en 7 couches pour une meilleure modularité.
        Par exemple, la couche présentation traduit les données (ex:
        chiffrement), tandis que la couche transport assure la fiabilité.
        Source: Chapitre 4, Section 2.1
    - text: >
        Le modèle OSI standardise les communications réseau. Chaque couche, comme
        la couche physique, utilise des normes spécifiques (ex: câbles
        Ethernet). Cela facilite l’interopérabilité mondiale. Source: Chapitre
        4, Section 2.1
    - text: >
        Dans OSI, la couche transport garantit une transmission fiable ou non
        selon les besoins. Par exemple, TCP est utilisé pour la fiabilité,
        contrairement à UDP. Source: Chapitre 4, Section 2.1
  utter_tcp_ip:
    - text: >
        *TCP/IP* (4 couches) : 1) Réseau physique 2) IP (acheminement) 3)
        Transport (TCP/UDP) 4) Application. Différence avec OSI : Plus
        pragmatique, optimisé pour Internet, moins de couches. Source: Chapitre
        4, Section 3
    - text: >
        Le modèle TCP/IP est conçu pour Internet, avec 4 couches au lieu de 7. La
        couche IP gère l’adressage et le routage, tandis que TCP assure une
        transmission fiable. UDP, en revanche, privilégie la rapidité. Source:
        Chapitre 4, Section 3
    - text: >
        TCP/IP est plus simple que OSI, avec une couche réseau physique combinant
        physique et liaison. La couche application inclut des protocoles comme
        HTTP, FTP, ou DNS. C’est le modèle dominant sur Internet. Source:
        Chapitre 4, Section 3
    - text: >
        Dans TCP/IP, la couche transport offre deux options : TCP (fiable, orienté
        connexion) et UDP (léger, sans connexion). Cela le rend flexible pour
        différents besoins, comme le streaming ou les transferts de fichiers.
        Source: Chapitre 4, Section 3
    - text: >
        TCP/IP est adapté aux réseaux réels, contrairement à OSI qui est plus
        théorique. La couche IP utilise des adresses comme 192.168.1.1 pour
        router les paquets. Source: Chapitre 4, Section 3
    - text: >
        Le modèle TCP/IP est largement adopté pour sa simplicité. Par exemple, la
        couche réseau gère le routage via des adresses IP, et UDP est idéal pour
        les applications temps réel. Source: Chapitre 4, Section 3
    - text: >
        TCP/IP combine les couches liaison et physique pour plus d’efficacité. La
        couche application gère des protocoles comme SMTP pour les e-mails.
        Source: Chapitre 4, Section 3
  utter_normalisation:
    - text: >
        *Organismes* : - ISO (OSI) - IEEE (LAN) - IETF (TCP/IP). Processus : draft
        → proposition → norme. Chaque organisme garantit des standards pour
        l’interopérabilité. Source: Chapitre 4, Section 4
    - text: >
        La normalisation réseau est gérée par des organismes comme l’ISO ou
        l’IETF. Le processus inclut des brouillons, des discussions, et une
        validation finale. Cela garantit que les équipements de différents
        fabricants fonctionnent ensemble. Source: Chapitre 4, Section 4
    - text: >
        L’IETF développe les standards Internet via des RFC (Request for
        Comments). L’IEEE gère les normes LAN comme Ethernet (802.3) ou Wi-Fi
        (802.11). L’ISO a créé le modèle OSI pour une vision universelle.
        Source: Chapitre 4, Section 4
    - text: >
        La normalisation permet une compatibilité mondiale des protocoles. Par
        exemple, l’ISO définit OSI, tandis que l’IETF standardise TCP/IP. Les
        normes évoluent avec les besoins technologiques. Source: Chapitre 4,
        Section 4
    - text: >
        Le processus de normalisation implique des experts qui proposent des
        standards. Ces standards, comme ceux de l’IEEE pour Ethernet, assurent
        une communication fiable. Source: Chapitre 4, Section 4
    - text: >
        Les normes réseau garantissent l’interopérabilité. Par exemple, l’IETF
        publie des RFC pour des protocoles comme HTTP ou DNS. Cela facilite le
        développement global. Source: Chapitre 4, Section 4
    - text: >
        La normalisation par l’IEEE inclut des standards comme 802.1Q pour les
        VLAN. Cela permet une configuration réseau flexible et sécurisée.
        Source: Chapitre 4, Section 4
  utter_encapsulation:
    - text: >
        *Encapsulation* : Une couche N encapsule les données de N+1 dans ses PDU.
        Exemple : Paquet IP dans trame Ethernet. Termes : SDU (Service Data
        Unit), PDU (Protocol Data Unit). Source: Chapitre 4, Section 1.3
    - text: >
        L’encapsulation permet à chaque couche d’ajouter ses propres en-têtes. Par
        exemple, un message HTTP est encapsulé dans un segment TCP, puis dans un
        paquet IP, et enfin dans une trame Ethernet. Cela garantit une
        transmission structurée. Source: Chapitre 4, Section 1.3
    - text: >
        Chaque couche encapsule les données de la couche supérieure. Une PDU
        réseau (paquet) contient une SDU transport (segment) plus un en-tête
        réseau. Cela permet une séparation claire des fonctions. Source:
        Chapitre 4, Section 1.3
    - text: >
        L’encapsulation est essentielle pour transmettre des données à travers les
        couches. Par exemple, la couche liaison ajoute des adresses MAC à la
        trame contenant un paquet IP. Source: Chapitre 4, Section 1.3
    - text: >
        Une PDU inclut les données (SDU) et des métadonnées (en-tête). Cela permet
        à chaque couche de gérer ses propres responsabilités, comme le routage
        ou la correction d’erreurs. Source: Chapitre 4, Section 1.3
    - text: >
        L’encapsulation structure les données pour le transport. Par exemple, une
        trame Ethernet inclut un paquet IP avec un en-tête contenant les
        adresses source et destination. Source: Chapitre 4, Section 1.3
    - text: >
        Chaque couche ajoute des informations spécifiques via l’encapsulation. Par
        exemple, la couche transport ajoute un numéro de port pour TCP ou UDP.
        Source: Chapitre 4, Section 1.3
  utter_primitives:
    - text: >
        *Primitives OSI* : - Request (demande) - Indication (notification) -
        Response (réponse) - Confirm (confirmation). Exemple : T_CONNECT.Request
        pour établir une connexion Transport. Source: Chapitre 4, Figure 4.1
    - text: >
        Les primitives OSI permettent la communication entre couches. Par exemple,
        N_CONNECT.Request demande à la couche réseau d’établir une connexion.
        Une Indication alerte la couche supérieure d’un événement. Source:
        Chapitre 4, Figure 4.1
    - text: >
        Une primitive comme L_DATA.Request envoie des données à la couche liaison.
        La réponse (Confirm) confirme que l’opération a réussi. Cela standardise
        les interactions entre couches. Source: Chapitre 4, Figure 4.1
    - text: >
        Les primitives OSI structurent les échanges entre couches. Par exemple,
        T_DISCONNECT.Indication signale la fin d’une connexion à la couche
        transport. Source: Chapitre 4, Figure 4.1
    - text: >
        Chaque primitive a un rôle spécifique : Request initie, Indication
        informe, Response répond, et Confirm valide. Cela garantit une
        communication fluide entre couches. Source: Chapitre 4, Figure 4.1
    - text: >
        Les primitives comme N_DATA.Request transportent des données réseau. Elles
        permettent une interaction standardisée entre les couches OSI. Source:
        Chapitre 4, Figure 4.1
    - text: >
        Une primitive OSI, comme T_CONNECT.Confirm, valide une connexion. Cela
        garantit que les couches communiquent efficacement. Source: Chapitre 4,
        Figure 4.1
  utter_lan_vs_wan:
    - text: >
        *LAN* (IEEE 802 avec MAC/LLC) vs *WAN* (OSI classique). LAN = réseaux
        locaux (ex: Ethernet), WAN = réseaux étendus (ex: Internet). LAN utilise
        des adresses MAC, WAN des adresses IP. Source: Chapitre 4, Section 2.3
    - text: >
        Un LAN couvre une petite zone (ex: bureau) avec des technologies comme
        Ethernet. Un WAN connecte des réseaux distants via des routeurs et des
        protocoles comme IP. Les LAN sont plus rapides, les WAN plus lents mais
        plus étendus. Source: Chapitre 4, Section 2.3
    - text: >
        Les LAN utilisent des protocoles comme IEEE 802.3 (Ethernet) avec des
        adresses MAC. Les WAN s’appuient sur IP et des équipements comme des
        routeurs pour connecter des sites. Source: Chapitre 4, Section 2.3
    - text: >
        Dans un LAN, les trames sont échangées directement entre machines via des
        commutateurs. Dans un WAN, les paquets IP traversent plusieurs routeurs
        pour atteindre leur destination. Source: Chapitre 4, Section 2.3
    - text: >
        La différence principale entre LAN et WAN est l’échelle géographique et
        les protocoles utilisés. Les LAN privilégient la vitesse, les WAN la
        couverture. Source: Chapitre 4, Section 2.3
    - text: >
        Les LAN utilisent des commutateurs pour connecter des appareils
        localement. Les WAN reposent sur des routeurs pour relier des réseaux
        distants. Source: Chapitre 4, Section 2.3
    - text: >
        Un LAN est limité à une zone physique, comme un bâtiment, tandis qu’un WAN
        peut couvrir des continents. Par exemple, un WAN utilise MPLS pour
        interconnecter des sites. Source: Chapitre 4, Section 2.3
  utter_exercices:
    - text: >
        *Exercices du chapitre 4* : 1. Choix des primitives (critères de
        conception) 2. Procédures en cas de panne (stratégies de reprise) 3.
        Établissement de connexions (échanges Liaison/Réseau) 4. SDU/PDU des
        niveaux Réseau/Liaison 5. Contenu des PDU 6. Primitives OSI (N_CONNECT,
        L_DATA) 7. Rôle des primitives 8. Relations PDU/SDU (calculs de taille)
        Dites-moi le numéro d'exercice qui vous intéresse. Source: Chapitre 4,
        Problèmes et exercices
    - text: >
        Les exercices du chapitre 4 couvrent des concepts clés de l’architecture
        réseau. Par exemple, l’exercice 1 traite des critères pour choisir des
        primitives. Indiquez un numéro pour plus de détails. Source: Chapitre 4,
        Problèmes et exercices
    - text: >
        Le chapitre 4 propose 8 exercices pour approfondir les concepts OSI et
        TCP/IP. Chaque exercice explore un aspect, comme l’encapsulation ou les
        pannes réseau. Quel exercice vous intéresse ? Source: Chapitre 4,
        Problèmes et exercices
    - text: >
        Les exercices du chapitre 4 sont conçus pour tester votre compréhension
        des couches réseau. Par exemple, l’exercice 3 analyse les échanges entre
        couches liaison et réseau. Choisissez un numéro pour commencer. Source:
        Chapitre 4, Problèmes et exercices
    - text: >
        Vous voulez explorer les exercices du chapitre 4 ? Ils incluent des sujets
        comme les primitives OSI, les pannes réseau, et les calculs de taille
        PDU/SDU. Donnez-moi un numéro ! Source: Chapitre 4, Problèmes et
        exercices
    - text: >
        Les exercices du chapitre 4 abordent des concepts pratiques. Par exemple,
        l’exercice 5 détaille le contenu des PDU pour chaque couche. Quel numéro
        d’exercice choisir ? Source: Chapitre 4, Problèmes et exercices
    - text: >
        Le chapitre 4 offre 8 exercices pour maîtriser les bases réseau. Par
        exemple, l’exercice 7 explore le rôle des primitives dans les
        connexions. Dites-moi un numéro ! Source: Chapitre 4, Problèmes et
        exercices
  utter_exercice_1:
    - text: >
        *Exercice 1 - Critères de choix des primitives* : 1. Définir clairement
        les services offerts 2. Minimiser le nombre de primitives 3. Réduire les
        paramètres par primitive Compromis : Simplicité vs richesse
        fonctionnelle. Cela garantit des interfaces efficaces et maintenables.
        Source: Chapitre 4, page 98
    - text: >
        L’exercice 1 explore comment concevoir des primitives OSI. Les critères
        incluent la clarté des services et la simplicité des paramètres. Cela
        évite des interfaces trop complexes. Source: Chapitre 4, page 98
    - text: >
        Dans l’exercice 1, il faut optimiser les primitives pour réduire la
        complexité. Par exemple, limiter le nombre de paramètres améliore la
        performance. Source: Chapitre 4, page 98
    - text: >
        Le choix des primitives dans l’exercice 1 repose sur des critères comme la
        modularité. Une primitive bien conçue simplifie les interactions entre
        couches. Source: Chapitre 4, page 98
    - text: >
        L’exercice 1 demande de prioriser des primitives avec peu de paramètres.
        Cela garantit une communication claire et efficace entre couches.
        Source: Chapitre 4, page 98
    - text: >
        Dans l’exercice 1, les primitives doivent être simples mais
        fonctionnelles. Par exemple, réduire les paramètres évite les erreurs de
        configuration. Source: Chapitre 4, page 98
    - text: >
        L’exercice 1 met l’accent sur la clarté des primitives OSI. Une conception
        simplifiée améliore l’interopérabilité des systèmes. Source: Chapitre 4,
        page 98
  utter_exercice_2:
    - text: >
        *Exercice 2 - Panne réseau (X.25)* : - Conséquence : Rupture du circuit
        virtuel - Signalement : Primitive Indication - Stratégies : Abandon ou
        reprise (mode dégradé) Cela simule une panne réelle dans un réseau X.25.
        Source: Chapitre 4, page 99
    - text: >
        L’exercice 2 analyse les pannes dans un réseau X.25. Une rupture de
        circuit virtuel est signalée par une primitive Indication. La reprise
        peut inclure un mode dégradé. Source: Chapitre 4, page 99
    - text: >
        Dans l’exercice 2, une panne réseau interrompt la communication. La
        primitive Indication alerte la couche supérieure, qui peut abandonner ou
        relancer. Source: Chapitre 4, page 99
    - text: >
        L’exercice 2 explore les stratégies face à une panne réseau. Par exemple,
        un circuit virtuel rompu nécessite une reprise ou un abandon. Source:
        Chapitre 4, page 99
    - text: >
        Pour l’exercice 2, la gestion des pannes repose sur des primitives. Une
        Indication signale la panne, et la stratégie dépend du contexte. Source:
        Chapitre 4, page 99
    - text: >
        L’exercice 2 simule une panne X.25 avec une rupture de connexion. La
        primitive Indication informe la couche transport pour agir. Source:
        Chapitre 4, page 99
    - text: >
        Dans l’exercice 2, une panne peut être gérée en mode dégradé. Cela permet
        de maintenir une communication partielle si possible. Source: Chapitre
        4, page 99
  utter_exercice_3:
    - text: >
        *Exercice 3 - Connexion Liaison/Réseau* : 1. Échanges avec LAP-B (trames
        SABM/UA) 2. En cas d'erreur : REJ ou retransmission 3. Ouverture CV :
        APPEL → COMMUNICATION_ETABLIE Voir figures 4.5 et 4.6 Cela simule une
        connexion entre couches. Source: Chapitre 4, pages 99-101
    - text: >
        L’exercice 3 détaille l’établissement d’une connexion avec LAP-B. Les
        trames SABM et UA ouvrent la connexion, tandis que REJ gère les erreurs.
        Source: Chapitre 4, pages 99-101
    - text: >
        Dans l’exercice 3, les couches liaison et réseau échangent des trames. Une
        erreur déclenche une retransmission ou un rejet (REJ). Source: Chapitre
        4, pages 99-101
    - text: >
        L’exercice 3 simule une connexion réseau via LAP-B. Les figures 4.5 et 4.6
        montrent les échanges de trames pour établir un circuit virtuel. Source:
        Chapitre 4, pages 99-101
    - text: >
        Pour l’exercice 3, l’ouverture d’un circuit virtuel utilise APPEL et
        COMMUNICATION_ETABLIE. Les erreurs sont gérées par des trames comme REJ.
        Source: Chapitre 4, pages 99-101
    - text: >
        L’exercice 3 analyse les interactions entre couches pour une connexion.
        Les trames LAP-B comme SABM initient la communication. Source: Chapitre
        4, pages 99-101
    - text: >
        Dans l’exercice 3, une erreur réseau peut déclencher une trame REJ. Cela
        permet de corriger les problèmes sans interrompre la connexion. Source:
        Chapitre 4, pages 99-101
  utter_exercice_4:
    - text: >
        *Exercice 4 - SDU/PDU* : - N_PDU : Paquets (APPEL, COMMUNICATION_ETABLIE)
        - L_SDU : Paquets encapsulés dans trames - L_PDU : Trames I/S/U (ex:
        I00, RR1) Cela montre l’encapsulation entre couches. Source: Chapitre 4,
        page 102
    - text: >
        L’exercice 4 explore les SDU et PDU entre les couches réseau et liaison.
        Les trames I/S/U transportent les paquets réseau. Source: Chapitre 4,
        page 102
    - text: >
        Dans l’exercice 4, un paquet réseau (N_PDU) devient une SDU pour la couche
        liaison. La trame liaison (L_PDU) inclut cette SDU plus un en-tête.
        Source: Chapitre 4, page 102
    - text: >
        L’exercice 4 détaille comment les paquets sont encapsulés dans des trames.
        Par exemple, une trame I00 transporte un paquet réseau. Source: Chapitre
        4, page 102
    - text: >
        Pour l’exercice 4, les trames liaison (L_PDU) incluent des paquets réseau
        (N_SDU). Cela illustre l’encapsulation entre couches. Source: Chapitre
        4, page 102
    - text: >
        L’exercice 4 montre l’encapsulation des paquets réseau. Une trame liaison
        comme RR1 confirme la réception correcte. Source: Chapitre 4, page 102
    - text: >
        Dans l’exercice 4, les PDU liaison transportent les SDU réseau. Cela
        garantit une transmission structurée entre couches. Source: Chapitre 4,
        page 102
  utter_exercice_5:
    - text: >
        *Exercice 5 - Contenu PDU* : - PDU(N) : Données + infos supervision -
        Exemple N=3 : Paquets APPEL/RR - Exemple N=2 : Trames I/SABM Cela montre
        le contenu des PDU par couche. Source: Chapitre 4, page 102
    - text: >
        L’exercice 5 analyse le contenu des PDU pour les couches réseau et
        liaison. Les paquets réseau incluent des données et des informations de
        contrôle. Source: Chapitre 4, page 102
    - text: >
        Dans l’exercice 5, une PDU réseau contient des paquets comme APPEL. À la
        couche liaison, les trames I ou SABM transportent ces données. Source:
        Chapitre 4, page 102
    - text: >
        L’exercice 5 montre comment les PDU varient selon les couches. Par
        exemple, une trame SABM est utilisée pour établir une connexion. Source:
        Chapitre 4, page 102
    - text: >
        Pour l’exercice 5, les PDU réseau incluent des paquets comme RR. Les
        trames liaison (I/S) transportent ces paquets avec des en-têtes. Source:
        Chapitre 4, page 102
    - text: >
        L’exercice 5 détaille les informations de supervision dans les PDU. Par
        exemple, une trame RR confirme la réception des données. Source:
        Chapitre 4, page 102
    - text: >
        Dans l’exercice 5, les trames liaison comme I00 incluent des paquets
        réseau. Cela illustre la structure des PDU par couche. Source: Chapitre
        4, page 102
  utter_exercice_6:
    - text: >
        *Exercice 6 - Primitives OSI* : - N_CONNECT.Indication : Émise par Réseau
        → Transport - L_DATA.Request : Réseau → Liaison (construction trames)
        Cela illustre les interactions entre couches. Source: Chapitre 4, page
        103
    - text: >
        L’exercice 6 explore les primitives comme N_CONNECT.Indication. Elles
        permettent à la couche réseau d’informer la couche transport. Source:
        Chapitre 4, page 103
    - text: >
        Dans l’exercice 6, L_DATA.Request envoie des données à la couche liaison.
        Cela construit des trames pour la transmission. Source: Chapitre 4, page
        103
    - text: >
        L’exercice 6 détaille les primitives OSI pour les échanges entre couches.
        Par exemple, N_CONNECT.Indication signale une connexion entrante.
        Source: Chapitre 4, page 103
    - text: >
        Pour l’exercice 6, les primitives comme L_DATA.Request sont essentielles.
        Elles permettent la construction de trames à la couche liaison. Source:
        Chapitre 4, page 103
    - text: >
        L’exercice 6 montre comment N_CONNECT.Indication facilite les connexions.
        Cela garantit une communication fluide entre couches. Source: Chapitre
        4, page 103
    - text: >
        Dans l’exercice 6, les primitives OSI structurent les interactions. Par
        exemple, L_DATA.Request prépare les données pour la transmission.
        Source: Chapitre 4, page 103
  utter_exercice_7:
    - text: >
        *Exercice 7 - Rôle primitives* : - N_CONNECT.Request : Transport → Réseau
        - Utilité : Établir circuit virtuel (X.25) - Confirmation via
        N_CONNECT.Confirm Cela montre l’initiation d’une connexion. Source:
        Chapitre 4, page 103
    - text: >
        L’exercice 7 analyse le rôle de N_CONNECT.Request. Cette primitive initie
        un circuit virtuel dans un réseau X.25. Source: Chapitre 4, page 103
    - text: >
        Dans l’exercice 7, N_CONNECT.Confirm valide l’établissement d’une
        connexion. Cela garantit une communication fiable entre couches. Source:
        Chapitre 4, page 103
    - text: >
        L’exercice 7 explore comment les primitives OSI établissent des
        connexions. N_CONNECT.Request est envoyé de la couche transport à la
        couche réseau. Source: Chapitre 4, page 103
    - text: >
        Pour l’exercice 7, les primitives comme N_CONNECT.Request sont clés. Elles
        permettent d’initier un circuit virtuel avec confirmation. Source:
        Chapitre 4, page 103
    - text: >
        L’exercice 7 montre l’importance de N_CONNECT.Confirm. Cette primitive
        valide que la connexion est établie correctement. Source: Chapitre 4,
        page 103
    - text: >
        Dans l’exercice 7, les primitives OSI comme N_CONNECT.Request sont
        essentielles. Elles garantissent une connexion réseau fiable. Source:
        Chapitre 4, page 103
  utter_exercice_8:
    - text: >
        *Exercice 8 - Relations PDU/SDU* : - Photo 448 Ko → 437 messages Transport
        - 3 589 paquets Réseau (128 octets) - TCP/IP : 7 segments (6×64 Ko + 1
        partiel) Cela calcule la fragmentation des données. Source: Chapitre 4,
        page 104
    - text: >
        L’exercice 8 calcule combien de paquets sont nécessaires pour une photo de
        448 Ko. Les messages transport sont divisés en paquets réseau de 128
        octets. Source: Chapitre 4, page 104
    - text: >
        Dans l’exercice 8, une photo de 448 Ko est divisée en 7 segments TCP/IP.
        Chaque segment est ensuite encapsulé en paquets réseau. Source: Chapitre
        4, page 104
    - text: >
        L’exercice 8 montre comment une grande quantité de données est fragmentée.
        Les 3 589 paquets réseau transportent les 437 messages transport.
        Source: Chapitre 4, page 104
    - text: >
        Pour l’exercice 8, les calculs PDU/SDU montrent la relation entre couches.
        Une photo de 448 Ko nécessite 7 segments TCP pour la transmission.
        Source: Chapitre 4, page 104
    - text: >
        L’exercice 8 analyse la fragmentation dans TCP/IP. Les segments transport
        sont divisés en paquets réseau pour la transmission. Source: Chapitre 4,
        page 104
    - text: >
        Dans l’exercice 8, une photo de 448 Ko illustre l’encapsulation. Les 7
        segments TCP sont répartis en 3 589 paquets réseau. Source: Chapitre 4,
        page 104
  utter_ask_ip_addressing:
    - text: >
        L’adressage IP utilise des adresses logiques de 32 bits, avec une partie
        réseau et une partie machine.  Par exemple, 193.27.45.33 (classe C) a 21
        bits pour le réseau et 8 pour la machine.  Les classes A, B, C
        définissent cette répartition, et des adresses spéciales comme 127.0.0.1
        (loopback) ou 255.255.255.255 (diffusion) existent.  Une question sur
        les classes, la notation décimale pointée, ou autre ?
    - text: >
        Une adresse IP de 32 bits est divisée en réseau et machine.  Par exemple,
        10.0.0.1 (classe A) utilise 8 bits pour le réseau.  La notation décimale
        pointée facilite la lecture.  Besoin d’explications sur les classes ou
        les adresses spéciales ?
    - text: >
        L’adressage IP permet d’identifier les appareils dans un réseau.  Une
        adresse comme 172.16.254.1 (classe B) a 16 bits pour le réseau.  Les
        adresses comme 0.0.0.0 (non spécifié) ont des usages spécifiques.  Un
        point à clarifier ?
    - text: >
        Les adresses IP sont structurées en classes (A, B, C, D, E).  Par exemple,
        192.168.1.1 est une classe C avec 24 bits pour le réseau.  Cela optimise
        le routage.  Une question sur les classes ou le routage ?
    - text: >
        L’adressage IP utilise des classes pour organiser les réseaux.  Une
        adresse comme 127.0.0.1 est réservée pour le loopback.  Les adresses de
        diffusion comme 255.255.255.255 atteignent tous les hôtes.  Besoin d’un
        exemple ?
    - text: >
        Une adresse IP comme 192.168.0.1 est souvent utilisée dans les réseaux
        locaux (classe C).  La partie réseau garantit un routage efficace.  Une
        question sur les adresses privées ?
    - text: >
        L’adressage IP repose sur une structure binaire.  Par exemple, 10.10.10.10
        est une classe A avec 8 bits réseau.  Cela facilite l’identification des
        appareils. Source: Chapitre 5, Section 5.1
  utter_ask_subnetting:
    - text: >
        Les sous-réseaux divisent un réseau via un masque, comme 255.255.255.224
        (/27), offrant 30 adresses par sous-réseau.  Par exemple, pour
        193.27.45.33/27, le sous-réseau est 193.27.45.32, avec une diffusion à
        193.27.45.63.  Voulez-vous calculer une adresse ou en savoir plus sur
        les masques ?
    - text: >
        Un masque de sous-réseau définit les sous-réseaux.  Par exemple, /24
        (255.255.255.0) donne 256 adresses par sous-réseau.  Pour
        192.168.1.10/24, le sous-réseau est 192.168.1.0.  Un calcul à faire ?
    - text: >
        Le sous-réseautage divise un grand réseau en plus petits.  Un masque /26
        (255.255.255.192) crée 4 sous-réseaux de 62 adresses.  Par exemple,
        10.0.0.5/26 appartient à 10.0.0.0.  Une question sur les masques ?
    - text: >
        Avec un masque /28, un réseau comme 172.16.0.0 donne 16 sous-réseaux de 14
        adresses.  La première adresse est réservée (réseau), la dernière est
        pour la diffusion.  Besoin d’un exemple de calcul ?
    - text: >
        Le sous-réseautage utilise un ET logique pour identifier le réseau.  Par
        exemple, 192.168.1.50 avec 255.255.255.240 (/28) donne le sous-réseau
        192.168.1.48.  Une adresse à analyser ?
    - text: >
        Un masque /29 crée 8 sous-réseaux de 6 adresses utilisables.  Par exemple,
        192.168.1.0/29 va de 192.168.1.0 à 192.168.1.7.  Un calcul de
        sous-réseau à faire ?
    - text: >
        Le sous-réseautage optimise l’utilisation des adresses IP.  Par exemple,
        /30 est idéal pour des liaisons point-à-point (2 adresses
        utilisables).  Une question sur les liaisons point-à-point ?
  utter_ask_cidr:
    - text: >
        CIDR utilise des masques flexibles (ex. /22) pour allouer des adresses
        sans classes fixes.  Par exemple, 193.33.32.0/22 offre 1024 adresses (10
        bits pour les machines).  Cela optimise l’espace d’adressage.  Besoin
        d’un exemple ou d’un calcul CIDR ?
    - text: >
        CIDR remplace les classes par des masques variables.  Par exemple, /20
        (255.255.240.0) donne 4096 adresses.  Une adresse comme 10.10.0.0/20
        couvre 10.10.0.0 à 10.10.15.255.  Un calcul à faire ?
    - text: >
        Avec CIDR, un masque /23 offre 512 adresses.  Par exemple, 172.16.0.0/23
        couvre 172.16.0.0 à 172.16.1.255.  Cela réduit le gaspillage
        d’adresses.  Une question sur CIDR ?
    - text: >
        CIDR permet une allocation précise des adresses.  Par exemple, /25
        (255.255.255.128) donne 128 adresses par sous-réseau.  Idéal pour les
        petits réseaux.  Besoin d’un exemple précis ?
    - text: >
        Le CIDR optimise l’espace IP en évitant les classes rigides.  Par exemple,
        192.168.0.0/24 peut être divisé en deux /25.  Cela améliore
        l’efficacité.  Une allocation à explorer ?
    - text: >
        CIDR utilise des masques comme /21 pour 2048 adresses.  Par exemple,
        10.0.0.0/21 couvre 10.0.0.0 à 10.0.7.255.  Un calcul CIDR à vérifier ?
    - text: >
        Avec CIDR, une plage comme 192.168.0.0/23 est divisible en sous-réseaux
        plus petits.  Cela permet une gestion flexible des adresses. Source:
        Chapitre 5, Section 5.3
  utter_ask_mac_ip_mapping:
    - text: >
        Une adresse MAC (48 bits, physique) identifie une carte réseau, tandis
        qu’une IP (32 bits, logique) situe un équipement dans un réseau.  ARP
        associe les deux via une requête diffusée.  Par exemple, pour
        192.168.1.2, ARP peut trouver 02:54:05:F4:DE:E5.  Une question sur ARP
        ou les tables ?
    - text: >
        Une adresse MAC est fixée par le fabricant, contrairement à l’IP,
        attribuée par le réseau.  ARP envoie une requête pour associer une IP à
        une MAC.  Par exemple, 10.0.0.1 peut correspondre à
        00:1A:2B:3C:4D:5E.  Un détail sur ARP ?
    - text: >
        ARP maintient une table de correspondance IP-MAC.  Une requête ARP est
        diffusée sur le réseau local pour trouver une MAC.  Par exemple,
        172.16.1.1 demande la MAC via une trame FF:FF:FF:FF:FF:FF.  Une
        explication sur les tables ARP ?
    - text: >
        La différence entre MAC et IP réside dans leur rôle : MAC pour la couche
        liaison, IP pour la couche réseau.  ARP résout cette correspondance
        localement.  Une question sur la diffusion ARP ?
    - text: >
        ARP est crucial pour les communications LAN.  Par exemple, une machine
        envoie une requête ARP pour trouver la MAC de 192.168.1.100.  La réponse
        met à jour la table ARP.  Besoin d’un exemple de trame ARP ?
    - text: >
        Une requête ARP utilise une trame avec le type 08 06.  Par exemple, pour
        192.168.1.10, la réponse donne la MAC associée.  Une question sur le
        protocole ARP ?
    - text: >
        ARP associe une IP à une MAC dans un LAN.  Par exemple, 10.0.0.2 peut
        correspondre à 00:14:22:33:44:55 après une requête. Source: Chapitre 5,
        Section 5.4
  utter_ask_fragmentation:
    - text: >
        La fragmentation divise un datagramme si sa taille dépasse la MTU.  Les
        champs Identification, DF, MF, et Déplacement gèrent cela.  Par exemple,
        un datagramme de 1480 octets (MTU 576) devient trois fragments de 552,
        552, et 376 octets.  Un exemple à détailler ?
    - text: >
        La fragmentation IP intervient quand un datagramme est trop grand.  Le
        champ MF indique s’il y a d’autres fragments, et Déplacement donne leur
        position.  Par exemple, un datagramme de 2000 octets (MTU 1500) est
        divisé en deux.  Un calcul à faire ?
    - text: >
        Un datagramme fragmenté utilise un Identifiant unique pour le
        réassemblage.  Par exemple, un datagramme de 3000 octets avec MTU 1000
        donne trois fragments.  Le bit DF interdit la fragmentation si
        défini.  Une question sur les champs ?
    - text: >
        La fragmentation est gérée par la couche réseau.  Chaque fragment a un
        en-tête IP avec Déplacement et MF.  Le dernier fragment a MF=0.  Besoin
        d’un exemple de réassemblage ?
    - text: >
        Les fragments sont réassemblés à destination grâce à l’Identifiant.  Par
        exemple, a datagramme de 4000 octets (MTU 1500) donne trois
        fragments.  Une explication sur la MTU ?
    - text: >
        La fragmentation divise un datagramme en morceaux compatibles avec la
        MTU.  Par exemple, un datagramme de 5000 octets (MTU 1500) donne 4
        fragments.  Une question sur le réassemblage ?
    - text: >
        Le champ Déplacement indique la position d’un fragment.  Par exemple, un
        fragment avec Déplacement=185 a 1480 octets précédents (185×8).  Un
        calcul de Déplacement ?
  utter_ask_interconnection_devices:
    - text: >
        Un répéteur régénère le signal (niveau 1), un pont filtre les trames par
        MAC (niveau 2), et un routeur achemine par IP (niveau 3).  Par exemple,
        un routeur relaie 193.27.45.33 via sa table de routage.  Une différence
        à clarifier ?
    - text: >
        Un répéteur fonctionne au niveau physique, amplifiant les signaux.  Un
        pont réduit les collisions en filtrant les trames MAC.  Un routeur
        utilise les adresses IP pour router.  Un équipement à détailler ?
    - text: >
        Les routeurs opèrent à la couche réseau, utilisant des tables de
        routage.  Par exemple, un paquet de 192.168.1.1 à 10.0.0.1 passe par un
        routeur.  Les ponts, eux, filtrent par MAC.  Une question sur les tables
        de routage ?
    - text: >
        Un pont connecte des segments LAN, réduisant le trafic inutile.  Un
        routeur connecte des réseaux différents, comme un LAN et un WAN.  Les
        répéteurs sont plus simples mais limités.  Un exemple à explorer ?
    - text: >
        Les équipements d’interconnexion varient par couche.  Un répéteur ne
        comprend pas les adresses, contrairement à un routeur.  Par exemple, un
        pont peut séparer deux VLAN.  Une différence à préciser ?
    - text: >
        Un routeur utilise des protocoles comme RIP ou OSPF pour router.  Par
        exemple, un paquet de 172.16.0.1 suit une table de routage.  Un pont n’a
        pas cette capacité.  Une question sur les protocoles de routage ?
    - text: >
        Les répéteurs sont utilisés pour étendre la portée d’un LAN.  Par exemple,
        ils régénèrent les signaux sur un câble Ethernet long. Source: Chapitre
        5, Section 5.6
  utter_ask_icmp_tools:
    - text: >
        Ping envoie un ICMP Echo Request (type 8) et attend un Echo Reply (type
        0).  Traceroute utilise Time Exceeded (type 11) avec un TTL
        incrémenté.  Par exemple, ping 8.8.8.8 teste la connectivité.  Un outil
        à explorer ?
    - text: >
        Ping mesure la latence et vérifie la connectivité.  Par exemple, un Echo
        Request à 8.8.8.8 retourne un Reply si l’hôte est actif.  Traceroute
        montre le chemin via des messages Time Exceeded.  Un résultat à analyser
        ?
    - text: >
        Traceroute incrémente le TTL pour identifier chaque routeur.  Par exemple,
        un TTL=1 provoque un Time Exceeded du premier routeur.  Ping utilise des
        messages ICMP simples.  Une question sur les messages ICMP ?
    - text: >
        Les outils ICMP comme ping testent la disponibilité.  Traceroute révèle
        les sauts entre source et destination.  Par exemple, traceroute
        google.com montre les routeurs traversés.  Un détail à clarifier ?
    - text: >
        Ping et traceroute utilisent ICMP pour diagnostiquer les réseaux.  Un ping
        à 192.168.1.1 avec un délai de 5 ms indique un réseau local
        rapide.  Traceroute peut montrer des pertes (étoiles).  Une explication
        sur les délais ?
    - text: >
        Un ping réussi retourne un Echo Reply avec un délai mesuré.  Par exemple,
        un ping à 10.0.0.1 avec 2 ms montre une connexion rapide.  Une question
        sur les délais ICMP ?
    - text: >
        Traceroute utilise des messages ICMP pour cartographier le chemin.  Par
        exemple, chaque saut retourne un Time Exceeded ou un Echo Reply. Source:
        Chapitre 5, Section 5.7
  utter_ask_frame_decoding:
    - text: >
        Un datagramme IP a un en-tête (version, TTL, adresses) et des
        données.  Une trame Ethernet l’encapsule avec des adresses MAC.  Par
        exemple, un datagramme de 193.27.45.33 montre une classe C.  Voulez-vous
        décoder une trame ou un datagramme précis ?
    - text: >
        Une trame Ethernet inclut un préambule, des adresses MAC, et un type (ex:
        08 00 pour IP).  Le datagramme IP contient des champs comme TTL et
        Protocole.  Par exemple, un datagramme ICMP a un type 8.  Un champ à
        décoder ?
    - text: >
        Le décodage d’une trame montre les adresses MAC source et destination.  Le
        datagramme IP encapsulé inclut les adresses IP et un checksum.  Par
        exemple, 192.168.1.1 vers 8.8.8.8.  Une trame à analyser ?
    - text: >
        Une trame Ethernet transporte un datagramme IP avec un en-tête précis.  Le
        champ Protocole indique si c’est TCP, UDP, ou ICMP.  Par exemple, 01
        signifie ICMP.  Une question sur les en-têtes ?
    - text: >
        Le décodage d’un datagramme IP révèle sa version (4 ou 6) et sa
        longueur.  Une trame Ethernet ajoute des informations comme le type 08
        06 pour ARP.  Un exemple de décodage à faire ?
    - text: >
        Une trame Ethernet a un champ Type pour identifier le protocole.  Par
        exemple, 08 00 indique un datagramme IP encapsulé.  Une question sur les
        types de trames ?
    - text: >
        Le décodage d’une trame Ethernet révèle les adresses MAC.  Par exemple,
        une trame avec MAC 00:14:22:33:44:55 transporte un paquet IP. Source:
        Chapitre 5, Section 5.8
  utter_ask_ipv6:
    - text: >
        IPv6 utilise 128 bits, supprime les classes, et favorise le
        multicast.  Son en-tête fixe et ses extensions (ex. hop-by-hop)
        améliorent la qualité de service.  Par exemple, il gère mieux les flux
        multimédias.  Une question sur IPv6 ?
    - text: >
        IPv6 résout la pénurie d’adresses avec 128 bits.  Par exemple, une adresse
        comme 2001:0db8::1 est simplifiée avec des zéros omis.  Il supprime les
        checksums d’en-tête pour plus d’efficacité.  Un détail sur IPv6 ?
    - text: >
        Contrairement à IPv4, IPv6 utilise des en-têtes d’extension.  Par exemple,
        l’en-tête hop-by-hop gère les options spécifiques.  Le multicast
        remplace la diffusion.  Une question sur le multicast ?
    - text: >
        IPv6 supporte mieux les applications multimédias grâce à ses
        en-têtes.  Par exemple, PMTU (Path MTU Discovery) optimise la
        fragmentation.  Les adresses 128 bits offrent une scalabilité.  Un
        exemple d’adresse IPv6 ?
    - text: >
        IPv6 élimine les classes d’adresses pour plus de flexibilité.  Par
        exemple, une adresse comme fe80::1 est utilisée pour les liens
        locaux.  Cela simplifie le routage.  Une explication sur les adresses
        locales ?
    - text: >
        Une adresse IPv6 comme 2001:0db8:85a3::8a2e:0370:7334 est unique.  La
        notation :: compresse les zéros pour plus de lisibilité.  Une question
        sur la notation ?
    - text: >
        IPv6 améliore le routage avec des adresses plus longues.  Par exemple, les
        adresses multicast comme ff02::1 ciblent des groupes spécifiques.
        Source: Chapitre 6, Section 6.1
  utter_ask_ip_service:
    - text: >
        IP offre un service sans connexion, routant des datagrammes
        indépendamment, sans garantie.  Par exemple, un datagramme de
        193.27.45.33 à 8.8.8.8 passe par des routeurs sans accusé.  Un point à
        approfondir ?
    - text: >
        Le protocole IP transmet des datagrammes sans garantir leur arrivée.  Par
        exemple, un paquet de 10.0.0.1 peut être perdu sans notification.  TCP
        ajoute la fiabilité si nécessaire.  Une question sur le routage ?
    - text: >
        IP est sans connexion, chaque datagramme étant routé indépendamment.  Les
        routeurs utilisent des tables pour diriger les paquets, comme de
        192.168.1.1 à 172.16.0.1.  Un détail sur les tables de routage ?
    - text: >
        Le service IP est simple mais non fiable.  Par exemple, un datagramme peut
        être fragmenté ou perdu en chemin.  Les protocoles supérieurs gèrent les
        erreurs.  Une explication sur la non-fiabilité ?
    - text: >
        IP achemine les datagrammes via des routeurs.  Par exemple, un paquet de
        172.16.1.1 vers 8.8.8.8 suit la meilleure route disponible.  Aucune
        confirmation n’est envoyée.  Un exemple de routage ?
    - text: >
        Le protocole IP est conçu pour être léger.  Par exemple, un datagramme de
        192.168.1.1 est routé sans vérification de réception.  Une question sur
        la légèreté d’IP ?
    - text: >
        IP ne garantit ni l’ordre ni la livraison des datagrammes.  Par exemple,
        un paquet peut arriver après un autre ou être perdu. Source: Chapitre 5,
        Section 5.2
  utter_ask_datagram_format:
    - text: >
        Un datagramme IP a un en-tête de 20 octets minimum (Version, TTL,
        adresses, etc.) et des données.  Par exemple, un TTL de 64 limite les
        sauts.  Le champ Protocole indique TCP, UDP, ou ICMP.  Un champ à
        expliquer ?
    - text: >
        L’en-tête IP inclut des champs comme Version (4 pour IPv4) et Longueur
        totale.  Par exemple, un datagramme avec Protocole=01 est ICMP.  Le TTL
        évite les boucles infinies.  Une question sur le TTL ?
    - text: >
        Le format d’un datagramme IP comprend un en-tête fixe et des données.  Le
        champ Identification aide au réassemblage des fragments.  Par exemple,
        un datagramme de 1500 octets peut être fragmenté.  Un champ à détailler
        ?
    - text: >
        L’en-tête IP contient des informations comme les adresses source et
        destination.  Le champ Type de Service (ToS) priorise les paquets.  Par
        exemple, un ToS élevé favorise le multimédia.  Une explication sur ToS ?
    - text: >
        Un datagramme IP a un en-tête avec des champs comme DF (ne pas
        fragmenter).  Par exemple, un datagramme avec DF=1 échoue si la MTU est
        trop petite.  Une question sur les bits de fragmentation ?
    - text: >
        Le champ Checksum dans l’en-tête IP vérifie l’intégrité.  Par exemple, un
        datagramme corrompu est rejeté par le routeur.  Une question sur le
        Checksum ?
    - text: >
        Un datagramme IP inclut un champ Longueur d’en-tête (IHL).  Par exemple,
        une valeur de 5 indique un en-tête de 20 octets. Source: Chapitre 5,
        Section 5.2
  utter_ask_icmp_protocol:
    - text: >
        ICMP gère les erreurs et diagnostics, comme Destination Unreachable (type
        3) ou Echo Request (type 8).  Par exemple, un TTL=0 déclenche un Time
        Exceeded.  Un type de message à détailler ?
    - text: >
        ICMP est utilisé pour signaler des erreurs, comme un port inaccessible
        (type 3, code 3).  Par exemple, un ping utilise Echo Request et
        Reply.  ICMP est encapsulé dans IP.  Une question sur les types ICMP ?
    - text: >
        Le protocole ICMP aide au diagnostic réseau.  Par exemple, un message Time
        Exceeded (type 11) indique un TTL épuisé.  Cela est utilisé par
        traceroute.  Un exemple de message ICMP ?
    - text: >
        ICMP ne transporte pas de données utilisateur, mais des messages de
        contrôle.  Par exemple, un Echo Request (type 8) teste la
        connectivité.  Les messages sont encapsulés dans des datagrammes
        IP.  Une explication sur l’encapsulation ?
    - text: >
        Les messages ICMP comme Destination Unreachable aident à diagnostiquer les
        problèmes.  Par exemple, un code 0 indique un réseau inaccessible.  ICMP
        est essentiel pour ping et traceroute.  Un type à explorer ?
    - text: >
        ICMP utilise des codes pour préciser les erreurs.  Par exemple, un type 3,
        code 1 indique un hôte inaccessible.  Une question sur les codes ICMP ?
    - text: >
        Le protocole ICMP est léger et efficace.  Par exemple, un message Echo
        Reply confirme la réception d’un ping. Source: Chapitre 5, Section 5.7
  utter_ask_exercise_1_principles:
    - text: >
        La séparation en deux parties (réseau et machine) réduit la taille des
        tables de routage, car les routeurs n’ont besoin que de l’identifiant
        réseau jusqu’à destination.  Par exemple, pour 193.27.45.33, seul
        193.27.45.0 est routé.  Une adresse IP ne peut pas être fixée par le
        fabricant car elle dépend du réseau connecté, garantissant unicité et
        structure.  Une question sur le routage ou l’unicité ?
    - text: >
        La division réseau/machine simplifie le routage.  Par exemple, 10.0.0.1
        (classe A) utilise 10.0.0.0 pour le routage.  Les adresses IP sont
        attribuées dynamiquement pour flexibilité.  Un point sur l’attribution ?
    - text: >
        Une adresse IP dépend du réseau pour éviter les conflits.  Par exemple,
        192.168.1.1 est unique dans son réseau local.  La séparation
        réseau/machine optimise les tables de routage.  Une question sur les
        conflits ?
    - text: >
        Les adresses IP ne sont pas fixées par les fabricants pour permettre
        l’adaptation au réseau.  Par exemple, 172.16.0.1 change si la machine
        rejoint un autre réseau.  Cela garantit l’unicité.  Un exemple à
        clarifier ?
    - text: >
        La séparation réseau/machine réduit la complexité du routage.  Par
        exemple, un routeur traite uniquement la partie réseau de
        193.27.45.33.  Cela améliore l’efficacité.  Une question sur
        l’efficacité ?
    - text: >
        Une adresse IP est attribuée selon le réseau pour assurer l’unicité.  Par
        exemple, 10.0.0.1 change dans un réseau 192.168.0.0.  Une question sur
        les adresses dynamiques ?
    - text: >
        La structure réseau/machine facilite le routage hiérarchique.  Par
        exemple, 172.16.1.1 est routé via 172.16.0.0. Source: Chapitre 5,
        Section 5.1
  utter_ask_exercise_2_classes:
    - text: >
        Pour 193.48.200.49, les premiers bits sont 110 (193 = 11000001), donc
        c’est une classe C (21 bits réseau, 8 bits machine).  Voulez-vous
        vérifier une autre adresse ?
    - text: >
        Une adresse comme 10.0.0.1 commence par 0, donc classe A (8 bits
        réseau).  Les classes déterminent la taille du réseau.  Une autre
        adresse à analyser ?
    - text: >
        Pour 172.16.0.1, les premiers bits sont 10 (classe B).  Cela donne 16 bits
        pour le réseau et 16 pour les machines.  Une question sur les bits ?
    - text: >
        L’adresse 192.168.1.1 est classe C (premiers bits 110).  Elle a 24 bits
        pour le réseau et 8 pour les machines.  Vérifier une autre classe ?
    - text: >
        Les classes IP sont identifiées par les premiers bits.  Par exemple,
        224.0.0.1 commence par 1110, donc classe D (multicast).  Une adresse à
        identifier ?
    - text: >
        Une adresse comme 127.0.0.1 est une classe A (loopback).  Les premiers
        bits (0) indiquent une plage réservée.  Une autre adresse à vérifier ?
    - text: >
        Les classes A, B, C divisent les adresses IP.  Par exemple, 169.254.0.1
        (classe B) est utilisé pour l’APIPA. Source: Chapitre 5, Section 5.1
  utter_ask_exercise_3_config:
    - text: >
        Pour A (143.27.102.101, masque 255.255.192.0), le sous-réseau est
        143.27.64.0 (102 & 192 = 64), avec une diffusion à 143.27.127.255.  B
        (143.27.172.101, même masque) est dans 143.27.128.0, donc un autre
        sous-réseau.  B ne peut pas utiliser le routeur 143.27.105.1, qui est
        dans le sous-réseau de A.  Un calcul à refaire ?
    - text: >
        Avec le masque 255.255.192.0, 143.27.102.101 est dans 143.27.64.0.  La
        diffusion est 143.27.127.255.  B (143.27.172.101) est dans un autre
        sous-réseau.  Une question sur les masques ?
    - text: >
        L’adresse 143.27.102.101 avec /18 (255.255.192.0) donne un sous-réseau de
        143.27.64.0.  B (143.27.172.101) est dans 143.27.128.0, donc non
        connecté au même routeur.  Un calcul à vérifier ?
    - text: >
        Le sous-réseau de A est calculé via un ET logique avec le masque.  Par
        exemple, 143.27.102.101 & 255.255.192.0 = 143.27.64.0.  B est dans un
        autre sous-réseau.  Une explication sur le ET logique ?
    - text: >
        La configuration de l’exercice 3 montre que A et B sont sur des
        sous-réseaux différents.  Le routeur 143.27.105.1 est inaccessible pour
        B.  Un détail sur la configuration ?
    - text: >
        Avec /18, le sous-réseau 143.27.64.0 couvre 16 384 adresses.  B
        (143.27.172.101) est dans 143.27.128.0, hors de portée du routeur de
        A.  Une question sur la portée ?
    - text: >
        L’exercice 3 illustre les sous-réseaux avec un masque /18.  A et B ne
        peuvent pas partager le même routeur. Source: Chapitre 5, Section 5.3
  utter_ask_exercise_4_mac_ip:
    - text: >
        Avec un réseau de classe B (identifiant 29C2 = 169.194), la 201e machine
        peut avoir l’IP 169.194.0.201.  Si déplacée, la MAC (3E:98:4A:51:49:76)
        reste inchangée, car fixée par le constructeur, mais l’IP doit changer
        pour correspondre au nouveau réseau.  Une autre adresse à proposer ?
    - text: >
        Dans un réseau 169.194.0.0 (classe B), la 201e machine peut être
        169.194.0.201.  La MAC reste fixe, mais l’IP change si le réseau
        change.  Une question sur la MAC ?
    - text: >
        Une adresse MAC est unique et fixée par le fabricant.  Par exemple,
        3E:98:4A:51:49:76 reste identique, mais l’IP 169.194.0.201 change si
        déplacée.  Une autre IP à calculer ?
    - text: >
        L’exercice 4 montre que l’IP dépend du réseau, pas la MAC.  Par exemple,
        169.194.0.201 devient 10.0.0.201 dans un autre réseau.  Un point sur la
        fixité de la MAC ?
    - text: >
        Pour la 201e machine dans 169.194.0.0, l’IP est 169.194.0.201.  La MAC ne
        change jamais, contrairement à l’IP.  Une autre configuration à explorer
        ?
    - text: >
        Une MAC comme 3E:98:4A:51:49:76 est gravée dans la carte réseau.  L’IP
        169.194.0.201 est attribuée par le réseau.  Une question sur
        l’attribution ?
    - text: >
        Dans l’exercice 4, l’IP change selon le réseau.  Par exemple,
        169.194.0.201 devient 192.168.1.201 ailleurs. Source: Chapitre 5,
        Section 5.4
  utter_ask_exercise_5_mapping:
    - text: >
        La machine 1 utilise ARP pour associer IP2 à PH2, en consultant sa table
        ARP ou en diffusant une requête.  Si la machine 2 est sur un autre
        réseau, le datagramme va au routeur (via ARP pour trouver sa MAC), avec
        une trame portant PH1 (source) et PHR (routeur).  Un détail sur ARP à
        clarifier
  utter_ask_exercise_6_subnets:
    - text: Pour 124.23.12.71/8 (classe A), réseau 124.0.0.0, diffusion
        124.255.255.255, pas de sous-réseau. Pour 124.12.23.71/24 (classe A),
        réseau 124.0.0.0, sous-réseau 124.12.23.0, diffusion 124.12.23.255. Pour
        194.12.23.71/28 (classe C), réseau 194.12.23.0, sous-réseau
        194.12.23.64, diffusion 194.12.23.79. Un calcul à vérifier ?
  utter_ask_exercise_7_address_plan:
    - text: Une classe B (x.y.0.0) avec masque 255.255.192.0 crée deux
        sous-réseaux  01 (x.y.64.0, diffusion x.y.127.255) et 10 (x.y.128.0,
        diffusion x.y.191.255). Chaque sous-réseau a 14 bits pour 16 382
        machines. Un exemple précis à explorer ?
  utter_ask_exercise_8_specific_plan:
    - text: Une classe B (65 534 adresses) suffit pour 2 853 machines. Sinon, 12
        classes C (254 adresses chacune) sont nécessaires. Pour 12 sous-réseaux
        sur 139.47.0.0, le masque est 255.255.240.0 (4 bits), laissant 12 bits
        (4 094 machines par sous-réseau). Le sous-réseau 9 est 139.47.144.0, la
        machine 7.48 est 139.47.151.48, et le sous-réseau 12 a réseau
        139.47.192.0, diffusion 139.47.207.255. Un point à détailler ?
  utter_ask_exercise_9_subnet_plan:
    - text: Pour 57 machines sur 193.22.172.0 (classe C), 6 sous-réseaux (5 groupes +
        serveurs) utilisent un masque 255.255.255.224 (/27), offrant 30 adresses
        par sous-réseau. Exemple :/ groupe 1 à 193.22.172.32, serveurs à
        193.22.172.192. Pour 4 sous-réseaux (15-30 postes), le même masque
        convient. Un plan à ajuster ?
  utter_ask_exercise_10_cidr:
    - text: Pour 800-900 machines, 193.33.32.0/22 (1024 adresses, masque
        255.255.252.0) convient parfaitement. Une autre allocation CIDR à
        analyser ?
  utter_ask_exercise_11_fragmentation:
    - text: Un fragment a MF=1 (sauf le dernier) et Déplacement non nul (sauf le
        premier). Le réassemblage utilise l’Identifiant commun et Déplacement.
        Deux fragments ne se confondent pas grâce à des Identifiants uniques. Un
        exemple de fragmentation à voir ?
  utter_ask_exercise_12_interconnection:
    - text: Pour connecter S1 (classe C) et S2 (classe B), un routeur par site est
        requis, via une liaison directe ou Internet. Les défis incluent un débit
        limité entre sites et la nécessité d’un plan d’adressage unifié (ex.
        utiliser la classe B avec sous-réseaux). Une solution à préciser ?
  utter_ask_exercise_13_devices:
    - text: Répéteur (niveau 1, simple, aucun filtrage), pont (niveau 2, filtre MAC,
        supprime collisions), routeur (niveau 3, filtre IP, complexe, sécurisé).
        Par exemple, un routeur gère les sous-réseaux, unlike un pont. Un
        critère à comparer ?
  utter_ask_exercise_14_ping:
    - text: L’IP 193.93.28.7 répond à un ICMP Echo Request (icmp_seq=0, TTL=255),
        prouvant qu’elle est opérationnelle. Le délai de 0.7 ms est court
        (réseau local). Aucun routeur n’est traversé (TTL max). Un détail sur
        ping à expliquer ?
  utter_ask_exercise_15_traceroute:
    - text: Le délai de 1 ms (première ligne) est typique d’un réseau local. Les
        étoiles indiquent des paquets perdus. Les délais varient à cause de
        congestions ou reroutages. 10 réseaux sont traversés (distincts par
        adresses réseau). Les protocoles au-delà d’IP ne sont pas visibles. Une
        ligne à analyser ?
  utter_ask_exercise_16_datagram:
    - text: Le datagramme 45 00 00 50… est IPv4 (4), en-tête 20 octets (5), longueur
        80 octets, ICMP (01), de 199.245.180.10 à 199.245.180.9 (classe C).
        C’est un ping (type 8, code 0) avec 56 octets de données. Un champ à
        décoder ?
  utter_ask_exercise_17_ethernet:
    - text: La trame Ethernet transporte le ping de 199.245.180.10 (MAC
        08:00:02:4B:02:D6) à 199.245.180.9 (MAC 08:00:02:4B:01:C3). Type 08 00
        (IP), constructeur 3Com. Un détail à clarifier ?
  utter_ask_exercise_18_ethernet_arp:
    - text: La trame FF FF FF… est une requête ARP dans 137.194.0.0 (classe B), de
        137.194.162.3 (MAC 00:04:80:5F:68:00) cherchant la MAC de
        137.194.162.243. Type 08 06 (ARP), avec bourrage. Une autre trame à
        décoder ?
  utter_nlu_fallback:
    - text: Désolé, je n'ai pas compris. Pouvez-vous reformuler ?
  utter_ask_2_exercice_2_classes:
    - text: Voici un exemple pour l'exercice 2 sur les classes...
  utter_utter_4_exercise_4_mac_ip:
    - text: Voici une explication pour l'exercice 4 sur la correspondance MAC-IP...
  utter_ask_4_exercise_4_mac_ip:
    - text: Pouvez-vous préciser votre question sur l'exercice 4 avec MAC-IP ?
  # A modifier
  utter_context_unsure:
    - text: >
        👍 Je suis là pour t’aider, mais peux-tu préciser sur quel sujet tu veux
        en savoir plus ?
  #############
  # Chapitres 7, 8 et 9
  utter_transport_protocol:
    - text: |
        Un protocole de transport fournit une interface permettant aux
        applications d’accéder aux services du réseau.

        Voici ses principales fonctions :

        - 🎯 **Identification des applications** : chaque application est identifiée par un **port** unique, ce qui permet à plusieurs applications de communiquer en même temps sur une même machine.

        - 🔌 **Communication via sockets** : une **socket** associe une adresse IP à un numéro de port, permettant d’identifier les extrémités de la communication.

        - 🛡️ **Vérification de l’intégrité** : pour s'assurer que les données n'ont pas été altérées pendant la transmission, le protocole utilise un **total de contrôle** (ou *checksum*), une méthode de détection d'erreurs.

        En résumé, le protocole de transport agit comme un intermédiaire fiable entre les applications et le réseau.

        👉 Souhaites-tu que je t’explique plus en détail la notion de **port** ou de **socket** ?
  utter_port:
    - text: |
        🔢 **Notion de port**

        Lorsqu'une machine exécute plusieurs applications en même temps, il est essentiel de pouvoir identifier clairement à quelle application doivent être livrées les données reçues. C’est là qu’intervient la notion de **port**.

        Un **port** est un identifiant numérique qui permet au protocole de transport de savoir pour **quelle application** il travaille. ⚠️ Attention, cela n’a rien à voir avec les ports physiques d’un commutateur réseau !

        💡 Sur certains systèmes d’exploitation, ce numéro de port peut être lié au **PID (Process Identifier)** du processus actif.

        📦 **Plage des ports** : - Les numéros de port sont codés sur **16 bits**, soit de **0 à 65535**. - Les ports **0 à 1023** sont appelés **ports bien connus** (*well-known ports*), réservés aux services système comme HTTP (80), FTP (21), etc. - Les autres ports (au-delà de 1023) sont généralement utilisés de manière dynamique par les clients ou pour des applications spécifiques.

        Ces affectations sont définies officiellement par l’**IANA** (*Internet Assigned Numbers Authority*), ce qui facilite la compatibilité entre les applications et les réseaux.

        Tu veux que je te montre une liste des ports les plus utilisés ?
  utter_list_ports:
    - text: |
        📘 Voici une liste de ports couramment utilisés :

        - 20/21 : FTP (transfert de fichiers) 
        - 22 : SSH (connexion sécurisée à distance) 
        - 23 : Telnet (connexion à distance non sécurisée) 
        - 25 : SMTP (envoi d’e-mails) - 53 : DNS (résolution de noms de domaine) 
        - 80 : HTTP (navigation web) - 110 : POP3 (réception d’e-mails) 
        - 143 : IMAP (réception d’e-mails) - 443 : HTTPS (navigation web sécurisée)
  utter_socket:
    - text: |
        🔌 **Notion de socket**

        Une **application** qui utilise TCP ou UDP doit être identifiée de manière unique sur une machine. Pour cela, le système d’exploitation utilise un **socket**, qui est une **paire** :

        🧩 `<adresse IP locale, numéro de port local>`

        👉 Cette paire permet d’identifier un **processus local** utilisant un protocole de transport.

        📡 Pour identifier une communication complète entre deux applications, on parle de **socket étendu** avec **5 éléments** :

        🧾 `<protocole, IP locale, port local ; IP distante, port distant>`

        Ainsi, une connexion TCP peut être totalement définie avec ces 5 éléments, assurant qu'elle est unique sur le réseau.

        Tu veux un **exemple concret** de socket en TCP ? 🔍
  utter_socket_example:
    - text: |
        🧪 **Exemple de socket en TCP** :

        Imaginons une application cliente (navigateur) qui se connecte à un serveur web.

        - **Côté client** :
          - Protocole : TCP
          - IP locale : 192.168.1.10
          - Port local : 50534 (choisi dynamiquement)

        - **Côté serveur** :
          - IP distante : 93.184.216.34
          - Port distant : 80 (HTTP)

        👉 Le socket complet est donc : `TCP, 192.168.1.10:50534 ; 93.184.216.34:80`

        Ce couple identifie **uniquement** cette session TCP dans tout l’Internet.
  utter_checksum:
    - text: |
        ✅ **Notion de total de contrôle (checksum)**

        Le **checksum** est une technique de **redondance** utilisée dans les protocoles TCP et UDP pour **vérifier l'intégrité des données** transmises.

        🧠 Il s’agit d’un calcul simple effectué sur les données du segment (souvent une **somme** des bits ou une **complémentation bit à bit**) pour détecter les erreurs de transmission.

        📏 Ce **champ de 16 bits** est placé dans l’**en-tête TCP ou UDP**. Sa position exacte dépend du protocole utilisé.

        🔍 Lorsqu’un paquet est reçu, le destinataire **recalcule** le checksum et le compare avec celui reçu dans l’en-tête. S’ils ne correspondent pas ➜ les données sont considérées comme corrompues.
  utter_ask_tcp_overview:
    - text: |
        📦 **Présentation générale de TCP (Transmission Control Protocol)** 

        Le protocole **TCP** est utilisé lorsque les applications ont besoin d’une **communication fiable** entre deux hôtes sur un réseau. Contrairement à IP, il corrige ses principales lacunes en offrant les services suivants :

        🔄 **Fiabilité** : détection et correction des erreurs lors de la transmission   🚦 **Contrôle de flux** : évite la surcharge du récepteur   🔐 **Contrôle de la connexion** : établit et maintient une communication cohérente entre les deux extrémités  

        🧱 TCP fonctionne avec une unité appelée **segment**. Voici comment ça marche :

        - Pour envoyer un segment :  
          👉 Le module TCP appelle IP avec une **Requête_émission(segment, adresse IP distante)**  

        - Pour recevoir un segment :  
          👉 Le module IP signale TCP avec une **Indication_réception(segment reçu, adresse IP source)**  

        L'interface TCP/IP est simple, mais celle entre TCP et les **applications utilisatrices** est plus complexe. On l’étudiera après avoir vu le **format du segment TCP** et le **cycle de vie d’une connexion**.

        ➕ **Souhaitez-vous que je vous explique :** 
        - 🧪 **Le fonctionnement de TCP étape par étape** (établissement, transfert, fermeture) ? 
        - 🧰 **Les primitives utilisées** dans les échanges TCP ? 
        - 📄 **Le format d’un segment TCP** avec ses champs ?
  utter_bout_en_bout:
    - text: |
        🔄 **Connexion de bout en bout en TCP**

        TCP fonctionne selon un modèle de **dialogue de bout en bout** :   📡 Une connexion est établie **directement entre les deux hôtes terminaux** — pas entre les routeurs, commutateurs ou autres équipements intermédiaires.

        📜 Décrit dans la [RFC 793](https://datatracker.ietf.org/doc/html/rfc793), TCP permet à deux applications distantes d’échanger des données de manière **fiable et ordonnée**, peu importe le chemin que les paquets prennent à travers le réseau.

        ⚙️ Pour cela : 
            - Une **connexion** est établie à la demande d’une application (via le **3-way handshake**)   
            - Un **contexte de connexion** est créé et maintenu des deux côtés (paramètres négociés, état de la communication, temporisations, etc.)   
            - Cette connexion est **gérée entièrement par les hôtes** (ordinateurs, serveurs…), **jamais par les routeurs** intermédiaires

        💬 Ce mode connecté signifie que : 
            - Les deux extrémités doivent être prêtes à communiquer   
            - Une demande doit être acceptée pour que la communication démarre   - On parle alors de **la vie de la connexion TCP**

        ➕ Tu veux que je t'explique : - 🔁 **Le cycle de vie complet d'une connexion TCP** ?
  utter_cycle_connexion_tcp:
    - text: |
        🔄 **Cycle de vie d'une connexion TCP**

        Une connexion TCP passe par trois phases essentielles : **ouverture**, **transfert de données**, puis **fermeture**, le tout géré par un **automate à 11 états**.

        ### 🔐 Ouverture : le *Three-Way Handshake* Une connexion débute par trois échanges entre le client et le serveur :

        1️⃣ Le **client** envoie un segment `SYN=1` avec un numéro de séquence initial `nseqE = x`.

        2️⃣ Le **serveur** répond avec `SYN=1, ACK=1`, contenant `nseqE = y` et `nseqR = x+1`.

        3️⃣ Le **client** finalise avec `ACK=1`, `nseqE = x+1` et `nseqR = y+1`.

        ✅ À l’issue de ces échanges, la connexion est établie et les deux hôtes peuvent échanger des données de manière fiable.

        ```text Client  →  SYN, nseqE = x Serveur ←  SYN, ACK, nseqE = y, nseqR = x+1 Client  →  ACK, nseqE = x+1, nseqR = y+1 ```

        ### 🔚 Fermeture : le *Four-Way Handshake* Comme TCP est bidirectionnel, chaque sens doit être fermé séparément :

        1. Un hôte envoie un segment `FIN=1` pour signaler la fin d'envoi. 2. L'autre répond avec `ACK`. 3. Il envoie à son tour un `FIN=1`. 4. Le premier répond par `ACK`.

        ➕ Ce processus implique **4 segments** pour garantir une libération propre des ressources.

        ⚠️ En cas de problème, une **fermeture brutale** avec `RST=1` est possible, signalant une fin anormale sans échange d'ACK.

        ### 📊 États TCP TCP utilise un **automate à 11 états** pour gérer chaque étape de la connexion (LISTEN, SYN_SENT, ESTABLISHED, FIN_WAIT_1, TIME_WAIT, etc.).

        Dans chaque état, seuls certains événements sont autorisés. Un mauvais événement déclenche une erreur.

        👉 Cette gestion par états garantit un contrôle précis et fiable de l’ensemble du cycle de connexion TCP.

        🖼️ **Diagramme des états TCP :** ![États TCP](https://ibb.co/sJpKsfPL.png)

        Souhaites-tu un exemple pratique de transitions d'états TCP ?
  utter_tcp_features:
    - text: |
        ⚙️ **Fonctionnalités avancées de TCP**

        TCP offre un service de transport **fiable et ordonné**, en s’appuyant sur plusieurs mécanismes clés :

        🔢 **Numérotation octet par octet**   Chaque octet est numéroté pour permettre la détection de pertes ou de duplications, et la remise en ordre à la réception.

        ✅ **Acquittements**   L’émetteur attend un accusé de réception pour chaque séquence de données envoyée. Cela permet de retransmettre les segments perdus.

        🪟 **Fenêtre d’anticipation (Sliding Window)**   - Gère la quantité de données qu’un émetteur peut envoyer sans attendre d’acquittement.   - Dépend de la capacité du tampon de réception de l’autre hôte.   - Sa taille est dynamique, ajustée selon la bande passante estimée en cours de communication.

        ⏱️ **Temporisateurs adaptatifs**   - Le temps d’attente pour un acquittement est ajusté dynamiquement en fonction des délais observés sur le réseau.   - Cela rend TCP plus efficace dans des réseaux variables.

        🚨 **Données urgentes (urgent data)**   TCP peut transmettre certaines données « urgentes » sans les soumettre au contrôle de flux classique.

        🔁 **Comparaison avec la couche liaison OSI**   Comme en liaison de données, TCP gère :   - Le séquencement   - Le contrôle de flux   - La détection et la correction des erreurs   Mais à la différence de la couche liaison, TCP agit **entre des hôtes distants** à travers un réseau potentiellement instable et multiple.

        ➕ Souhaitez-vous explorer : - 🪟 La **gestion détaillée de la fenêtre glissante** ? - ⏱️ Le **fonctionnement des temporisateurs adaptatifs** ? - 🚨 Ou comment sont traitées les **données urgentes en TCP** ? - 📊 Un tableau comparatif entre TCP et un protocole comme HDLC ou PPP ? - 🔍 Un exemple concret illustrant les différences de comportement ?
  utter_tcp_comparatif_data_link_table:
    - text: |
        📊 Voici un tableau comparatif simplifié :

        | Fonction               | Liaison (ex. : PPP)         | Transport (TCP)             |
        |------------------------|-----------------------------|-----------------------------| 
        | Couche OSI             | 2 – Liaison de données      | 4 – Transport               | 
        | Type de communication | Direct (support physique)   | Bout en bout (via IP)        | 
        | Adressage              | MAC                         | IP + Port                   | 
        | Contrôle de flux       | Oui                         | Oui                         | 
        | Réémission             | Locale                      | Bout en bout                | 
        | Nbre de connexions     | 1 souvent                   | Plusieurs simultanées       | 
        | Ordre des données      | Garanti par le support      | Doit être restauré          |

        ➕ Tu veux qu’on applique ça à un scénario concret (comme un téléchargement FTP) ?
  utter_tcp_vs_ppp_example:
    - text: |
        🔍 Imaginons un fichier téléchargé depuis Internet :

        - **PPP (liaison)** : gère les trames entre ton ordinateur et ton routeur, sur la ligne ADSL ou fibre. 
        - **TCP (transport)** : gère la fiabilité de l’échange **entre ton PC et le serveur distant**, même à travers plusieurs routeurs.
  utter_tcp_segment_format:
    - text: |
        📦 Le **segment TCP** contient un en-tête structuré suivi éventuellement
        de **données**.

        Voici les principaux champs de l’en-tête TCP (sans options) : !"https://ibb.co/F4QVJCqh" 🔹 **Port source** (16 bits) : identifie l’application côté émetteur   🔹 **Port destination** (16 bits) : identifie l’application côté récepteur   🔹 **Numéro de séquence** (32 bits) : identifie le premier octet de données envoyées   🔹 **Numéro d’accusé de réception** (32 bits) : indique le prochain octet attendu   🔹 **Longueur d’en-tête (Data Offset)** (4 bits) : longueur de l’en-tête TCP (en mots de 32 bits)   🔹 **Réservé** (6 bits) : réservé pour des usages futurs   🔹 **Drapeaux (flags)** (6 bits) : contrôlent la communication :
            - URG : données urgentes  
            - ACK : acquittement  
            - PSH : envoi immédiat aux applications  
            - RST : réinitialisation de la connexion  
            - SYN : ouverture de connexion  
            - FIN : fermeture de connexion  
        🔹 **Fenêtre** (16 bits) : taille de la fenêtre de réception (contrôle de flux)   🔹 **Total de contrôle (Checksum)** (16 bits) : vérifie l’intégrité du segment   🔹 **Pointeur d’urgence** (16 bits) : indique la position des données urgentes   🔹 **Options** (taille variable) : permettent d’ajouter des fonctionnalités comme :
            - **MSS (Maximum Segment Size)** : taille max des segments acceptés  
            - **Timestamp** : mesure du RTT (temps aller-retour)  
            - **Window Scale** : extension de la taille de la fenêtre (> 65 535 octets)  
            - **SACK permitted** : permet les acquittements sélectifs  
        🔹 **Remplissage (padding)** : aligne l’en-tête sur un multiple de 4 octets   🔹 **Données** : transport de l'information de l’application (et données urgentes si URG)

        🧪 Exemple : Sur un réseau Ethernet, la MSS vaut souvent **1460 octets** (1500 - 40 d’en-têtes IP + TCP)

        🔍 Souhaitez-vous un exemple de  segment TCP ?
  utter_connexion_tcp:
    - text: |
        🔐 **Ouverture d’une connexion TCP : le Three-Way Handshake**

        Une connexion TCP débute par une procédure en **trois étapes** entre un **client** et un **serveur**, appelée *three-way-handshake* :

        1️⃣ Le **client** initie la connexion avec un segment contenant le drapeau `SYN=1` et un **numéro de séquence initial** `nseqE = x`.

        2️⃣ Le **serveur**, après une ouverture passive, répond avec un segment `SYN=1, ACK=1`, contenant :
           - `nseqE = y` (son propre numéro de séquence initial)
           - `nseqR = x + 1` (accusé de réception du SYN du client)

        3️⃣ Le **client** finalise l’ouverture avec un segment `ACK=1` :
           - `nseqE = x + 1`
           - `nseqR = y + 1` (accusé de réception du SYN du serveur)

        ✅ À l’issue de ces 3 échanges, la connexion est établie : les deux parties connaissent les numéros de séquence de départ et peuvent commencer à transmettre des données de manière fiable.

        ⚙️ **Schéma de l’échange :**

        ``` Client  →  SYN, nseqE = x, nseqR = 0 Serveur ←  SYN, ACK, nseqE = y, nseqR = x+1 Client  →  ACK, nseqE = x+1, nseqR = y+1 ```

        🧭 Le client doit connaître à l’avance le **numéro de port** de l’application serveur. Les ports standards sont souvent utilisés (ex : 80 pour HTTP, 443 pour HTTPS), mais des ports personnalisés sont possibles.

        👉 Ce mécanisme assure une **synchronisation fiable** entre les deux hôtes avant tout échange de données.

        Voulez-vous une explication sur le mécanisme de fermeture ?
  utter_fermeture_tcp:
    - text: |
        🔚 *Fermeture d’une connexion TCP*

        La fermeture d'une connexion TCP suit un processus en **quatre étapes**, car une connexion TCP est **bidirectionnelle** : chaque sens doit être fermé indépendamment.

        🧩 *Étapes de la fermeture normale* : 1. Un côté (client ou serveur) envoie un segment avec le drapeau `FIN = 1` pour indiquer qu'il a terminé l'envoi de données. 2. L'autre côté répond avec un segment `ACK`, accusant réception du FIN. 3. Ensuite, le second côté envoie son propre segment `FIN` pour signaler qu’il a aussi terminé l’envoi de ses données. 4. Le premier côté répond à son tour avec un `ACK`, complétant ainsi la fermeture.

        ➕ Chaque flux est fermé séparément, ce qui explique pourquoi **quatre segments sont nécessaires** (contrairement aux trois lors de l'ouverture).

        ⚠️ *Fermeture brutale (RST)* : En cas de problème (ex. fermeture inattendue d'une application), un module TCP peut envoyer un segment avec `RST = 1`. - Ce segment peut contenir les derniers octets en attente. - Aucun `ACK` n’est attendu. - Le destinataire traite les données restantes, puis signale une **fin anormale** de la connexion à l’application.
  utter_etats_tcp:
    - text: |
        TCP utilise un automate à 11 états pour gérer les connexions. Parmi les
        états : LISTEN, SYN_SENT, ESTABLISHED, FIN_WAIT, TIME_WAIT, etc.

        Ces états représentent les différentes étapes d'établissement, de transfert de données et de fermeture d'une connexion TCP.

        On voit que l’ouverture et la fermeture d’une connexion dépendent de nombreux événements et peuvent conduire à beaucoup de situations différentes. Une représentation commode des étapes de l’établissement et de la libération d’une connexion TCP se fait en utilisant un automate d’états finis à onze états (voir tableau 7.2). Dans chaque état, seuls certains événements sont autorisés et une action précise est entreprise. Dans le cas où l’événement n’est pas autorisé, on renvoie un signal d’erreur.

        Souhaites-tu un exemple de l'état d'une connexion TCP

        La figure suivante donne les transitions d’états de l’automate d’une connexion TCP :
      image: https://i.ibb.co/93mbyDvR/automate.jpg
  utter_temporisation_tcp:
    - text: |
        TCP utilise des temporisateurs pour assurer la fiabilité des
        transmissions. À chaque envoi de segment, un minuteur est déclenché.  Si
        l’accusé de réception (ACK) n’est pas reçu avant l’expiration de ce
        délai, TCP considère le segment comme perdu et le retransmet.

        Pour gérer cette temporisation, TCP mesure le RTT (Round Trip Time), c’est-à-dire le temps aller-retour entre l’envoi d’un segment  et la réception de son acquittement. Ce délai peut fortement varier selon la distance, la qualité du réseau et le trafic.

        Par exemple : - ping 192.168.0.2 ⟶ RTT ≈ 6 ms (réseau local) - ping 203.50.4.178 ⟶ RTT ≈ 358 ms (vers l’Australie)

        Grâce à ces mesures dynamiques, TCP ajuste automatiquement ses temporisations pour optimiser la fiabilité et l’efficacité des transferts.
  utter_algorithmes_tcp:
    - text: |
        TCP optimise ses performances grâce à plusieurs algorithmes
        :  **Jacobson** affine le calcul du délai d’attente en tenant compte du
        RTT et de sa variation ; Karn évite les erreurs d’estimation en excluant
        les RTT des segments retransmis ; Nagle et Clark limitent l'envoi de
        petits paquets pour améliorer  l'efficacité des échanges
        interactifs.  Souhaitez-vous en savoir plus sur l’un de ces algorithmes
        en particulier ?
  utter_algorithm_jacobson:
    - text: |
        L’algorithme de Jacobson est utilisé par TCP pour ajuster dynamiquement la
        temporisation (timeout) en fonction des conditions du réseau.

        ⚙️ Pourquoi c’est nécessaire ? Si la temporisation est trop courte → retransmissions inutiles.   Si elle est trop longue → performances dégradées.   Il faut donc une estimation **précise et adaptative** du délai d’attente.

        📏 L’idée de Jacobson : On mesure en continu le RTT (Round Trip Time), c’est-à-dire le temps entre l’envoi d’un segment TCP et la réception de son ACK. Pour éviter de réagir à de simples variations momentanées, on utilise une **moyenne pondérée** :

        RTT_estimé = a × RTT_estimé + (1 – a) × Nouveau_RTT   ➤ Avec a ≈ 7/8, donc plus de poids au passé pour lisser les fluctuations.

        🧮 Ensuite, on évalue la **variabilité** du RTT avec une estimation d’écart :

        D = (1 – a) × |RTT_estimé – Nouveau_RTT|

        🕓 Enfin, on fixe la temporisation avec une marge de sécurité proportionnelle à la variabilité :

        Temporisation = RTT_estimé + 4 × D

        ✅ Résultat : une temporisation adaptative, plus longue quand le réseau est instable, plus courte quand il est stable.
  utter_algorithm_karn:
    - text: |
        🔄 **Algorithme de Karn** (TCP) :   Il résout un problème d’ambiguïté lié
        aux accusés de réception (ACK) lorsque des segments sont retransmis.

        📌 Problème : Lorsqu’un segment est retransmis, on ne peut pas savoir si l’ACK reçu correspond au segment original ou au retransmis. Cela fausse le calcul du RTT (Round Trip Time) si on le met à jour dans ce contexte.

        ✅ Solution (algorithme de Karn) : - **Ignorer** les mesures de RTT pour les segments retransmis. - **Conserver** la temporisation précédente. - **Augmenter** la temporisation en cas de nouvelle expiration :
          Nouvelle temporisation = g × Temporisation (avec g ≈ 2, stratégie de backoff).

        🧠 Avantage :   Cela évite de fausser la mesure du RTT et limite les surévaluations entraînant des délais excessifs.

        Voulez-vous d'autres que je donne d'autres temporisateurs utilisés par TCP ?
  utter_autres_temporisateurs_tcp:
    - text: |
        ⏱️ **Autres temporisateurs utilisés par TCP** :

        1. **Temporisateur de persistance** : - Évite le blocage mutuel quand le récepteur a une fenêtre de réception nulle. - Il envoie des "probes" pour vérifier si la fenêtre est réouverte.

        2. **Temporisateur de limitation d’attente (keep-alive)** : - Vérifie si la connexion est toujours active après une longue période d’inactivité. - Peut entraîner une fermeture si aucune réponse n’est reçue.

        3. **Temporisateur TIME-WAIT** : - Utilisé après la fermeture d’une connexion. - Dure 2 fois la durée de vie maximale d’un segment pour garantir qu’aucun segment résiduel ne subsiste sur le réseau.

        📦 Ces temporisateurs améliorent la fiabilité, la robustesse et la gestion efficace des ressources TCP.
  utter_algorithm_clark_nagle:
    - text: |
        📉 **Syndrome de la fenêtre stupide (Silly Window Syndrome)** : Ce
        problème survient lorsque l’émetteur envoie de tout petits segments de
        données, souvent un octet à la fois, ce qui sature inutilement le réseau
        et dégrade les performances de TCP.

        🧠 **Solution — Algorithme de Clark (côté récepteur)** : - Le récepteur n’annonce pas une mise à jour de fenêtre pour de très petites tailles (comme 1 octet). - Il attend soit :
          - que le tampon soit à moitié vide, **ou**
          - qu’un segment de taille maximale puisse être reçu.
        ✅ Cela réduit le nombre de mises à jour inutiles et évite d’encourager l’envoi de petits segments.

        🚀 **Solution — Algorithme de Nagle (côté émetteur)** : - L’émetteur envoie **le premier octet seul**, puis attend son acquittement. - Ensuite, il accumule les données dans un tampon et les envoie toutes d’un coup. - Cette méthode évite d’inonder le réseau avec des segments minuscules.

        🧩 **Complémentarité** : - Ces deux algorithmes sont **compatibles et souvent utilisés ensemble**. - Clark évite les petites fenêtres côté récepteur. - Nagle évite les petits envois côté émetteur.

        📊 **Objectif commun** : - Réduire la surcharge réseau due aux petits paquets, - Optimiser les performances TCP, en particulier pour les applications interactives comme les sessions SSH ou Telnet.
  utter_controle_congestion_tcp:
    - text: |
        📶 **Contrôle de congestion TCP** : TCP utilise un algorithme adaptatif
        pour éviter la saturation du réseau. Il ajuste dynamiquement la
        **fenêtre de congestion (congestion window)** en fonction des accusés de
        réception (ACK) et des expirations de temporisation (timeouts).

        📌 **Fonctionnement global** : TCP maintient deux fenêtres : - La **fenêtre de réception** (donnée par le récepteur), - La **fenêtre de congestion** (gérée par l’émetteur pour éviter de surcharger le réseau).

        L’expéditeur ne peut envoyer qu’un nombre d’octets égal au **minimum** de ces deux fenêtres.

        🚀 **Phase 1 – Démarrage lent (Slow Start)** : - La taille de la fenêtre de congestion commence à 1 MSS (Maximum Segment Size). - À chaque ACK reçu, la taille double (croissance **exponentielle**). - Cette croissance continue jusqu’à atteindre un seuil appelé **"seuil d’évitement de congestion" (ssthresh)**.

        ⚠️ **Détection de congestion (Timeout)** : - Si un segment n’est pas acquitté à temps, on considère qu’il y a congestion. - Le seuil est alors fixé à la moitié de la fenêtre courante. - La fenêtre de congestion est **réinitialisée à 1 MSS**.

        📉 **Phase 2 – Évitement de congestion (Congestion Avoidance)** : - Dès que la fenêtre atteint `ssthresh`, la croissance devient **linéaire** : +1 MSS par fenêtre réussie. - Cela permet de stabiliser l’envoi de données et de prévenir la surcharge du réseau.

        📊 **Illustration (figure)** : - 📈 De 0 à 8 : croissance exponentielle (Slow Start). - 🟥 À 13 : **perte de segment** → timeout → réinitialisation. - 📉 De 14 à 24 : croissance **linéaire** (Congestion Avoidance), après une nouvelle croissance exponentielle jusqu’au seuil.

        🧠 **Conclusion** : Ce mécanisme permet à TCP de détecter et réagir à la congestion **sans surcharge excessive du réseau**, en adaptant dynamiquement sa vitesse d’envoi en fonction des retours du réseau.
      image: https://i.ibb.co/F4xTbH7y/evoution-fenetre-congestion.jpg
  utter_interface_tcp_application:
    - text: |
        🧩 **Interface entre TCP et l'application** :

        Les processus applicatifs communiquent via **des sockets TCP**, une abstraction logicielle qui permet d’envoyer et de recevoir des données à travers une connexion réseau fiable.

        🔧 **Côté serveur** : - `socket()` : création de la socket. - `bind()` : association à une adresse IP et un numéro de port. - `listen()` : mise en attente des connexions entrantes. - `accept()` : accepte une connexion entrante et crée une nouvelle socket dédiée.

        🖥️ **Côté client** : - `socket()` : création de la socket. - `connect()` : demande de connexion à un serveur (initie la connexion TCP).

        🔄 **Échange de données** : - `read()` / `write()` : primitives standards pour lire et écrire dans la socket. - ou bien `recv()` / `send()` : équivalents souvent utilisés. - parfois `recvfrom()` / `sendto()` : surtout pour UDP, mais utilisables selon l’implémentation.

        ❌ **Fermeture de la connexion** : - `close()` : termine la connexion côté client (**fermeture active**) ou côté serveur (**fermeture passive**).

        ⚙️ Ces primitives permettent aux applications client/serveur de **gérer la communication réseau** sans avoir à manipuler les détails internes de TCP.
  utter_ask_primitive:
    - text: Quelle primitive veux-tu que je détaille ? Bind, Listen, Connect, Accept,
        Read, Write, Close, etc. ?
  utter_udp_intro:
    - text: |
        📡 **UDP (User Datagram Protocol)** : un protocole simple et rapide

        UDP est un **protocole de transport sans connexion**, ce qui signifie qu’il **n’établit pas de lien préalable** entre l’émetteur et le récepteur avant de transmettre des données.

        ✳️ Contrairement à TCP, UDP : - 🚫 **n'assure pas la fiabilité** de la transmission (pas de garantie de livraison) - 🚫 **n’assure pas l’ordre d’arrivée** des paquets - 🚫 **ne gère pas la détection ni la correction d’erreurs complexes** - ✅ **ne provoque pas de délais supplémentaires** liés à des mécanismes de contrôle

        🔄 Il ne fournit **aucune fonctionnalité de contrôle de flux, de congestion ou de retransmission**.

        ⚙️ UDP se contente d’encapsuler les données dans des datagrammes et de les envoyer “tel quel”.

        🎯 Il est utilisé dans les applications où : - la **rapidité prime sur la fiabilité** (ex : streaming, VoIP, DNS) - les applications peuvent elles-mêmes gérer les erreurs ou pertes - la surcharge de TCP est jugée inutile

        📌 En résumé : UDP est idéal pour des transmissions **légères et rapides**, au prix d’une fiabilité minimale.
  utter_udp_services:
    - text: |
        ⚙️ **UDP fournit un service minimal et efficace**, bien adapté aux
        applications qui nécessitent rapidité et faible surcharge.

        🔹 UDP transmet les données sous forme de **datagrammes de petite taille**, sans établir de connexion ni attendre d’accusé de réception.

        ✅ Ce fonctionnement est idéal pour : - les **applications en temps réel** comme le **streaming audio/vidéo** - les **jeux en ligne**, où la rapidité est plus critique que la fiabilité - les **services de type question-réponse** (petits messages, réponses rapides)

        🛠️ La **gestion des erreurs** (perte de données, duplication…) est **laissée à l’application**, souvent via des mécanismes de **temporisation**.

        📚 Parmi les services fonctionnant au-dessus d’UDP, on trouve : - 🌐 **DNS** (Domain Name System) — service d’annuaire - 📡 **SNMP** (Simple Network Management Protocol) — gestion réseau - 🧭 **RIP** (Routing Information Protocol) — routage - 🔍 Utilitaire système **traceroute** (sur Unix), qui envoie des datagrammes UDP avec un TTL limité pour analyser le chemin réseau

        📝 En résumé : UDP est **minimaliste mais performant**, utilisé dès que la fiabilité peut être gérée par l’application ou qu’elle est peu critique.

        ❓Souhaites-tu savoir comment UDP se compare à TCP dans un contexte pratique ? Ou veux-tu des exemples concrets d’applications qui utilisent l’un ou l’autre ?
  utter_udp_header_structure:
    - text: |
        📦 **Structure de l'en-tête UDP**

        Un datagramme UDP est composé de deux parties : un **en-tête** et les **données utilisateur**. Il est encapsulé dans un datagramme IP, comme les segments TCP.

        L’en-tête UDP est **très simple** et occupe **8 octets**. Il contient **4 champs** de 16 bits chacun :

        🔹 **Port source** : numéro de port de l’application émettrice. Sert d’adresse de réponse pour le destinataire.

        🔹 **Port destination** : numéro de port de l’application réceptrice (côté serveur, par exemple).

        🔹 **Longueur** : taille totale du datagramme UDP (en-tête + données), en octets. La longueur maximale des données est de **65 472 octets**.

        🔹 **Checksum (somme de contrôle)** : permet de **vérifier l'intégrité** de l'en-tête et des données. Bien qu’optionnel dans IPv4, il est obligatoire en IPv6.

        ✅ Sa simplicité permet un traitement très rapide des paquets, ce qui en fait un protocole idéal pour les **communications rapides et peu coûteuses**.
      image: https://i.ibb.co/svFVhxxN/en-t-te-udp.jpg
  utter_udp_socket_interface:
    - text: |
        🔌 **Interface entre UDP et les applications**

        Les applications interagissent avec UDP via des **sockets UDP**, qui sont très simples à utiliser car **UDP fonctionne sans connexion** :

        ➤ **Pas d’établissement ni de fermeture de connexion** : contrairement à TCP, les sockets UDP ne nécessitent ni `connect()` ni `close()`.

        ### 🎛️ Côté serveur : - Créer un socket. - Lier le socket à un numéro de port avec la primitive **`Bind`**. - Mettre le socket en attente avec la primitive **`Listen`** (bien que dans UDP, ce soit souvent implicite).

        ### 📲 Côté client : - Créer un socket. - Envoyer et recevoir directement les données avec **`SendTo`** et **`ReceiveFrom`**, ou des équivalents comme **`Write`** et **`Read`**.

        ✅ Ce modèle sans connexion est idéal pour les **applications légères et réactives**.

        ❓Souhaites-tu un exemple de code client/serveur utilisant les sockets UDP ?
  utter_udp_vs_tcp:
    - text: |
        TCP et UDP sont les deux principaux protocoles de transport dans
        l’architecture TCP/IP.  TCP est un protocole complet, en mode connecté,
        qui assure la fiabilité, l’ordre, le contrôle de flux,  d’erreur et de
        congestion. Il est adapté aux applications exigeant des transferts
        fiables de données,  comme le web ou le transfert de fichiers.

        UDP, plus simple et léger, ne garantit ni la fiabilité ni l’ordre des paquets. Il se contente d’acheminer  les messages via IP, sans contrôle ni correction. Il est idéal pour les applications en temps réel  ou les communications rapides de type requête/réponse, comme le streaming ou DNS.

        Souhaitez-vous comparer leurs cas d’usage plus en détail ou voir un exemple concret ?
  utter_primitive_detail:
    - text: |
        La primitive {primitive} permet d'interagir avec les sockets UDP. Pour
        plus de détails, consulte la documentation de ton OS ou la base de
        données.
  utter_udp_use_cases:
    - text: |
        UDP est privilégié pour les applications en temps réel ou celles qui
        tolèrent la perte de données. Il est utilisé dans le streaming
        audio/vidéo, les jeux en réseau, ou les services de type
        requête/réponse  comme DNS, SNMP ou RIP. Grâce à sa légèreté et à
        l'absence d'accusé de réception, il permet  des communications rapides
        avec peu de surcharge.

        UDP est efficace pour envoyer de petits paquets à haut débit, sans garantie de livraison.  C’est l’application, et non le protocole, qui gère les pertes éventuelles — souvent avec des mécanismes de temporisation.  Par exemple, la commande traceroute utilise UDP pour envoyer des paquets à durée de vie limitée.

        N'hésitez à poser des questions sur le reseau, je suis ici pout t'aider :) .
  utter_transport_protocols_summary:
    - text: |
        Deux protocoles de transport sont utilisés : TCP, fiable et complexe, pour
        les échanges importants ; et UDP, simple et rapide, adapté aux
        applications avec contraintes de temps.
  utter_tcp_vs_udp:
    - text: |
        TCP est utilisé pour les échanges fiables et volumineux, tandis qu'UDP
        convient aux communications rapides et simples où la perte de données
        est tolérable.
  utter_tcp_advantages:
    - text: |
        🔐 **Avantages du protocole TCP**

        TCP (Transmission Control Protocol) est un protocole de transport **orienté connexion**, conçu pour garantir un **échange de données fiable**. Voici ses principaux atouts :

        ### ✅ Fiabilité assurée grâce à plusieurs mécanismes : - **Contrôle d’erreurs** : détection et retransmission des segments perdus. - **Séquencement** : réassemblage des segments dans l’ordre d’envoi. - **Contrôle de flux** : régulation du débit entre émetteur et récepteur. - **Contrôle de congestion** : évite la surcharge du réseau.

        ### 📦 Format d’en-tête unique Tous les segments TCP ont un **même format d’en-tête** de 20 octets (hors options), qu’il s’agisse d’ouverture, de transfert ou de fermeture de connexion. 👉 Cela **simplifie et optimise le traitement** des paquets.

        ### 🔄 Mode connecté Grâce à l’établissement de connexion : - Les paramètres sont **mémorisés des deux côtés** (contexte partagé). - Permet une **gestion fine** du flux et des délais. - Essentiel pour les applications critiques (HTTP, FTP, SSH...).

        ### 📶 TCP réordonne les segments Bien qu’IP puisse fragmenter les datagrammes, **TCP réordonne les données** car IP ne garantit pas leur ordre d’arrivée.

        ### 🌐 Gestion de connexions multiples TCP peut gérer **des centaines de connexions simultanément**. Chaque connexion est identifiée de manière unique par une paire de **sockets** : ``` (IP_source, Port_source) ↔ (IP_destination, Port_destination) ``` Cela permet, par exemple, à un navigateur web d’ouvrir plusieurs connexions pour charger les ressources d’une seule page.

        📊 **Exemple de calcul de débit utile** : - Ethernet à 10 Mbit/s, trame de 1 528 octets, données utiles TCP = 1 460 octets - Débit utile ≈ 10 × (1460 / 1528) = **9,55 Mbit/s**

        ❓Souhaites-tu une illustration schématique de l’établissement de connexion TCP (3-way handshake) ou un exemple de code TCP client/serveur ?
  utter_udp_simplicity:
    - text: |
        UDP est plus léger que TCP, sans gestion de connexion ni de fiabilité, ce
        qui le rend utile pour les applications temps réel comme le streaming ou
        les jeux en ligne.
  utter_tcp_throughput:
    - text: |
        Sur Ethernet à 10 Mbit/s, en tenant compte des 40 octets d'en-tête IP et
        TCP,  le débit utile maximal est environ 9,55 Mbit/s pour 1460 octets
        utiles sur 1528 transmis.
  utter_tcp_header_format:
    - text: |
        TCP utilise un seul format de segment pour simplifier le traitement,
        optimiser les performances  et permettre une implémentation cohérente
        pour tous les types de communication (connexion, transfert, fermeture).

        Souhaitez-vous plus de détail sur l'en-tête TCP ou les types de communications TCP ?
  utter_tcp_connection_context:
    - text: |
        Le mode connecté permet à TCP de gérer un contexte de communication, avec
        contrôle de flux,  correction d'erreurs, numérotation, et adaptation
        dynamique aux conditions du réseau.
  utter_tcp_segment_order:
    - text: |
        Comme IP ne garantit pas l'ordre des datagrammes, TCP numérote les octets
        et réordonne les segments  à la réception pour assurer la cohérence des
        données pour l'application.
  utter_tcp_multiple_connections:
    - text: |
        🔄 **Multiples connexions TCP simultanées**

        Oui, **TCP peut gérer plusieurs connexions en parallèle**, grâce à une **identification unique** pour chaque connexion via une paire de sockets : ``` (adresse IP source, port source) ↔ (adresse IP destination, port destination) ```

        Voulez-vous un exemple de connecions TCP simultanées ?
  utter_exemple_tcp_multiple_connections:
    - text: |
        ***Gestion de plusieurs connexions par TCP*** **Exemple: ### 🛜
        Implémentation du protocole TCP Le protocole TCP est **implémenté
        uniquement au niveau des hôtes** (postes clients/serveurs), pas dans les
        routeurs. - 📍 Les routeurs R1 et R2 se limitent à la **couche IP**. -
        Ce sont donc **PC1 et PC2** qui gèrent les connexions TCP.

        ### 🌐 Plusieurs connexions avec un même hôte PC1 peut avoir **plusieurs connexions simultanées avec PC2**, par exemple : - Web : `(IP_PC1, port_x) ↔ (IP_PC2, port_80)` - FTP : `(IP_PC1, port_y) ↔ (IP_PC2, port_21)` 👉 Le **changement de numéro de port** côté client permet à TCP de **différencier les connexions**.

        ### 🧩 Réouverture d'une connexion après interruption Si PC1 **interrompt brutalement** sa connexion avec le service Web et en ouvre une **nouvelle** : - TCP **attribuera un nouveau numéro de séquence initial** (tiré au hasard). - ✅ Aucun risque d’interférence entre segments de l’ancienne et de la nouvelle connexion.

        ❓Souhaites-tu une visualisation de cette gestion des connexions TCP à travers un schéma ou un exemple de trace réseau (Wireshark) ?
  utter_tcp_connection_identification:
    - text: |
        Le port élevé ({client_port}) indique que la machine {client_ip} est
        probablement un client.  Le port bas ({server_port}), ici typique d'un
        serveur Web (port 80), indique que {server_ip} est le serveur. Les
        adresses IP appartenant à des réseaux différents impliquent qu'un ou
        plusieurs routeurs sont traversés.
  utter_tcp_ping_vs_tcp_connection:
    - text: |
        Vous utilisez la commande **netstat** sur votre ligne de commande,  vous
        constatez que vous avez une connexion TCP ouverte avec la machine
        213.33.44.55, port 1863 dans l’état ESTABLISHED. ✅ Vous avez une
        connexion TCP `ESTABLISHED` avec la machine `213.33.44.55`, port `1863`
        (MSN). Pourtant, un ping envoyé vers cette machine ne reçoit aucune
        réponse.

        👉 Cela **ne signifie pas** que la machine est hors service.

        🔐 En réalité, la machine ou un routeur intermédiaire **filtre les requêtes ICMP Echo Request** pour des raisons de sécurité (protection contre certaines attaques ou masquage de l’hôte).

        ⚠️ Résultat : la commande `ping` ne peut plus être utilisée comme indicateur fiable de disponibilité.

        🧠 **Conclusion :** Une machine qui ne répond pas au ping peut être toujours opérationnelle au niveau applicatif, notamment via TCP.
  utter_tcp_same_vs_different_networks:
    - text: |
        TCP fonctionne de la même manière que les machines soient sur le même
        réseau ou sur des réseaux différents. Dans les deux cas, un segment TCP
        est encapsulé dans un datagramme IP contenant les adresses IP source et
        destination. La différence réside dans le traitement au niveau des
        couches inférieures : sur un même réseau, la trame contient directement
        les adresses MAC des deux machines.
  utter_tcp_netstat_analysis:
    - text: |
        L’analyse des statistiques netstat montre que 7 connexions TCP sont
        actuellement actives. Le trafic est bien équilibré entre les segments
        envoyés et reçus. Le nombre très faible de retransmissions (10 sur plus
        de 107 000 segments envoyés) indique une bonne qualité de transmission,
        avec un taux d’erreur très bas, de l’ordre de 2*10⁻⁸ si l’on considère
        une taille typique de segment TCP. Les "ouvertures actives"
        correspondent aux connexions initiées par la machine, et les "ouvertures
        passives" à celles reçues.
  utter_tcp_advanced_statistics:
    - text: |
        Les statistiques montrent une activité réseau typique d’un serveur : les
        segments envoyés sont en moyenne de 1388 octets, tandis que ceux reçus
        sont bien plus petits (135 octets), ce qui suggère que cette machine
        envoie de gros volumes de données et reçoit peu (probablement des
        requêtes). 91% des paquets reçus contiennent des acquittements (ACK),
        chacun validant environ 2,33 Ko de données. Les pertes de segments sont
        probablement dues à la congestion ou l’instabilité réseau. Les paquets
        "window update" et "window probe" servent à ajuster dynamiquement la
        fenêtre TCP. Les paquets de contrôle sont utilisés pour gérer
        l'ouverture et la fermeture des connexions. Sur 356 demandes de
        connexion, seules 92 ont été acceptées (75% d'échec), probablement à
        cause d’un contrôle d’accès (login/mot de passe). Le volume moyen émis
        par connexion est de 5 Mo, contre 24 Ko reçus. Le RTT a été mis à jour
        fréquemment (86% des cas), mais il y a eu très peu d’expirations de
        timeout (21), et aucun abandon dû au mécanisme Keepalive : les
        connexions sont donc stables et bien gérées.
  utter_tcp_segment_decoding:
    - text: |
        📦 **Exemple de décodage d’un segment TCP donné en hexadécimal :**

        **Segment hexadécimal analysé :**   `00 15 0F 87 9C CB 7E 01 27 E3 EA 01 50 12 10 00 DF 3D 00 00`

        🔍 **Analyse des champs TCP :** - **Port source :** 21 → Il s’agit d’un **serveur FTP** (port bien connu). - **Port destination :** 3975 → Port utilisé par le **client**. - **Numéro de séquence :** `9C CB 7E 01` → Premier octet émis. - **Numéro d’accusé de réception :** `27 E3 EA 01` → Premier octet attendu. - **Longueur de l’en-tête :** 20 octets → Aucun octet de données. - **Drapeaux :**
          - `SYN` = 1 → Demande ou réponse d’ouverture de connexion.
          - `ACK` = 1 → Présence d’un accusé de réception.
          - Autres drapeaux (FIN, RST, PSH, URG) = 0.
        - **Taille de la fenêtre :** 4096 octets → Taille de la fenêtre d’envoi autorisée. - **Checksum :** `DF 3D` → Contrôle d’erreur. - **Pointeur urgent :** `00 00` → Aucun pointeur de données urgentes.

        📌 **Bilan :** - Ce segment TCP est une **réponse positive à une ouverture de connexion** (SYN + ACK). - Le serveur FTP accepte la connexion et envoie un numéro de séquence initial. - Le segment ne contient pas de données utiles. - Ce type de segment s’inscrit dans la **phase d’établissement de la connexion TCP** (3-way handshake). - Le contexte machine n’est pas connu, mais il s’agit vraisemblablement de l’**initialisation d’un transfert FTP**.

        ❓ **Et vous ?** Êtes-vous capable d’identifier les drapeaux activés et la nature de la communication dans un segment TCP hexadécimal donné ?
  utter_ethernet_frame_full_analysis:
    - text: |
        Soit la trame Ethernet suivante:

        AA AA AA AA AA AA AA AB 08 00 20 0A 70 66 08 00 20 0A AC 96 08 00 45  00 00 28 A6 F5 00 00 1A 06 75 94 C0 5D 02 01 84 E3 3D 05 00 15 0F 87  9C CB 7E 01 27 E3 EA 01 50 12 10 00 DF 3D 00 00 20 20 20 20 20 20 9B  52 46 43


        La trame Ethernet commence par : - Synchronisation : AA AA AA AA AA AA AA AB - MAC destination : 08:00:20:0A:70:66 - MAC source : 08:00:20:0A:AC:96 - Type : 08 00 → datagramme IP

        En-tête IP (20 octets) : - Version : IPv4, Longueur de l’en-tête : 20 octets - Longueur totale : 40 octets - Identifiant : A6F5 - Pas de fragmentation (DF=1, MF=0) - TTL : 26 - Protocole : TCP (06) - IP source : 192.92.2.1 - IP destination : 132.227.61.5 - Somme de contrôle IP : 7594

        Segment TCP : - Port source : 21 (serveur FTP) - Port destination : 3975 (client) - Flags SYN et ACK activés → réponse positive à la demande de connexion - Fenêtre : 4 096 octets - Pas de données, en-tête de 20 octets seulement

        Trame Ethernet complétée avec 6 octets de bourrage (20 20 20 20 20 20) pour atteindre 64 octets, suivie d’un CRC : 9B 52 46 43.

        **Interprétation réseau** :  Cette trame peut avoir été capturée : - **Dans le réseau source (192.92.2.0)** : le serveur FTP initie une réponse vers le client via un routeur de sortie. - **Dans le réseau destination (132.227.0.0)** : le routeur d’entrée relaie une réponse TCP au client FTP. - **Dans un réseau de transit** : entre routeurs intermédiaires, avec MACs inconnues des machines terminales.

        Il s’agit d’un transfert FTP en cours d’établissement de connexion.
  utter_objectifs_du_routage:
    - text: Le routage permet de déterminer le chemin qu'un message doit emprunter
        pour atteindre sa destination, en tenant compte de critères comme la
        distance ou le débit.
  utter_boucles_de_routage:
    - text: Les boucles de routage sont des situations où un message tourne
        indéfiniment dans le réseau sans atteindre sa cible. Elles doivent être
        évitées.
  utter_panne_et_recalcul:
    - text: Lors d'une panne, les routeurs doivent recalculer rapidement les nouvelles
        routes en contournant la liaison défectueuse.
  utter_protocoles_routage:
    - text: Les protocoles comme RIP (vecteur de distance) et OSPF (état des liens)
        permettent d'échanger les informations de routage entre routeurs.
  utter_hierarchisation_reseau:
    - text: Pour gérer la croissance du réseau, on le découpe en régions avec des
        tables de routage hiérarchiques, ce qui réduit la charge sur les
        routeurs.
  utter_systeme_autonome:
    - text: Un système autonome est un ensemble de réseaux interconnectés sous la même
        autorité administrative, utilisant un protocole de routage commun.
  utter_difference_igp_egp:
    - text: L'IGP est utilisé à l'intérieur d'un système autonome, tandis que l'EGP
        gère les échanges de routage entre différents systèmes autonomes.
  utter_protocole_rip:
    - text: RIP (Routing Information Protocol) est un protocole de routage interne
        basé sur la distance, limitant le nombre de sauts à 15 et utilisant des
        métriques fixes pour déterminer les chemins.
  utter_fonctionnement_rip:
    - text: RIP utilise un algorithme à vecteur de distance basé sur le nombre de
        routeurs traversés. Il limite la longueur des chemins à 15 sauts.
  utter_limites_rip:
    - text: RIP gère mal les boucles et ne s’adapte pas aux critères temps réel comme
        le délai ou la charge. Il est inadapté aux grands réseaux.
    - text: RIP peut créer des boucles si une liaison tombe. Par exemple, A et B
        peuvent se renvoyer une route vers C, croyant tous deux qu'elle est
        encore valide, même après panne.
  utter_variantes_rip:
    - text: "Deux variantes améliorent RIP : Split-Horizon et Split-Horizon with
        Poison-Reverse, pour limiter les boucles de routage."
  utter_exemple_rip:
    - text: Un exemple de boucle entre A, B et C montre que RIP peut produire des
        erreurs de routage lorsqu’une liaison tombe en panne.
  utter_ripv2:
    - text: RIPv2 ajoute des informations comme le masque de sous-réseau et des
        étiquettes pour distinguer les routes internes et externes.
  utter_rip_udp:
    - text: RIP fonctionne sur la couche application et utilise UDP comme transport
        avec le port 520.
  utter_ameliorations_rip:
    - text: "Des solutions ont été proposées pour RIP : acquittements, métriques
        multiples, rupture de synchronisation... mais OSPF reste préféré."
  utter_protocole_ospf:
    - text: OSPF (Open Shortest Path First) est un protocole de routage à état de
        liens, basé sur l'algorithme de Dijkstra, utilisant plusieurs critères
        pour évaluer les coûts des chemins.
  utter_fonctionnement_ospf:
    - text: Chaque routeur OSPF construit sa propre base de données topologique et
        calcule indépendamment le plus court chemin. Le système peut être
        hiérarchisé en zones.
  utter_messages_ospf:
    - text: "OSPF utilise cinq types de messages : hello, description de base de
        données, requête d’état de lien, mise à jour d’état de lien, et
        acquittement."
  utter_securite_ospf:
    - text: OSPF protège ses messages par des totaux de contrôle, l’authentification
        et la temporisation. Cela empêche les erreurs ou attaques qui
        fausseraient les tables de routage.
  utter_routeur_bgp:
    - text: Un routeur BGP est un routeur de bordure dans un SA qui accepte le
        transit. Il dialogue avec les routeurs BGP des SA voisins pour établir
        les routes interdomaines.
  utter_comparaison_algorithmes:
    - text: Les algorithmes à état des liens convergent plus rapidement, supportent
        des métriques multiples, permettent des chemins multiples, et gèrent
        mieux les routes externes que les algorithmes à vecteurs de distance.
  utter_diffusion_multicast:
    - text: La diffusion multicast transmet un message à un groupe d’utilisateurs.
        Elle peut être implémentée par inondation, routage multidestination,
        arbre couvrant, ou l’algorithme RFP.
  utter_routage_multicast:
    - text: Le routage multicast utilise des arbres couvrants ou l’algorithme RFP pour
        limiter les doublons. Chaque routeur décide selon la provenance du
        message s'il s'agit d’un paquet original ou d’un doublon.
  utter_igmp_gestion_groupes:
    - text: IGMP (RFC 2236) permet la gestion dynamique des groupes multicast, en
        informant les routeurs des adhésions ou départs des hôtes. Les routeurs
        adaptent ensuite les routes multicast.
  utter_routage_mobilite:
    - text: Pour les utilisateurs mobiles, on utilise des agents de domiciliation et
        des agents extérieurs pour suivre et router les messages en fonction de
        leur localisation temporaire.
  utter_peer_to_peer:
    - text: Les réseaux peer-to-peer peuvent être totalement distribués (sans contrôle
        central) ou hybrides (avec une station de coordination). Ils posent des
        défis en termes de localisation et de routage des ressources.
  utter_types_routage:
    - text: "Il existe deux types principaux d’algorithmes de routage : à vecteurs de
        distance (calculent le chemin le plus court en nombre de sauts) et à
        état des liens (calculent en fonction de métriques de coût)."
  utter_protocole_bgp:
    - text: BGP (Border Gateway Protocol) est le protocole de routage interdomaine
        utilisé mondialement pour échanger des informations entre systèmes
        autonomes.
  utter_fonctionnement_bgp:
    - text: BGP échange des routes complètes entre routeurs de bordure via TCP (port
        179). Il utilise un algorithme à vecteurs de distance mémorisant tout le
        chemin, ce qui convient au routage inter-SA.
  utter_dhcp_definition:
    - text: DHCP (Dynamic Host Configuration Protocol) est un protocole client/serveur
        qui attribue automatiquement des adresses IP et d'autres paramètres
        réseau aux machines d'un réseau TCP/IP.
  utter_dhcp_ports:
    - text: Le protocole DHCP utilise les ports UDP 67 (serveur) et 68 (client).
  utter_dhcp_messages:
    - text: "Les messages DHCP sont : DHCPDiscover, DHCPOffer, DHCPRequest, DHCPAck,
        DHCPDecline, et DHCPRelease."
  utter_dhcp_use_cases:
    - text: DHCP est utile pour configurer automatiquement un grand nombre de machines
        sur un réseau, en leur attribuant des adresses IP uniques sans
        configuration manuelle.
  utter_dhcp_fixed_vs_dynamic:
    - text: Une adresse IP dynamique est temporaire et attribuée automatiquement,
        tandis qu'une adresse IP fixe est permanente et souvent utilisée pour
        les serveurs. DHCP permet aussi l'attribution fixe via l'adresse MAC.
  utter_dhcp_bail:
    - text: Un bail DHCP est la durée pendant laquelle une adresse IP est attribuée à
        un client. Elle peut être renouvelée à expiration.
  utter_dhcp_security:
    - text: Des risques existent, comme l'usurpation d'un serveur DHCP. Il est
        possible pour un attaquant de se faire passer pour un serveur DHCP pour
        compromettre le réseau.
  utter_expliquer_dns:
    - text: Le DNS (Domain Name System) permet de traduire un nom de domaine en
        adresse IP, rendant les sites web accessibles par des noms lisibles
        plutôt que des adresses numériques.
    - text: "DNS ({protocole}) traduit les noms de domaine en adresses IP (ex.: www.example.com → 93.184.216.34)."
  utter_resolution_dns:
    - text: La résolution DNS commence par une requête envoyée au résolveur, qui
        contacte un serveur racine, puis un serveur TLD, et enfin un serveur
        autoritaire pour obtenir l'adresse IP correspondant au nom demandé.
  utter_types_enregistrements_dns:
    - text: "Les principaux types d'enregistrements DNS sont : A (adresse IPv4), AAAA
        (IPv6), MX (mail exchange), CNAME (alias), NS (serveur de noms), etc."
  utter_dns_hierarchique:
    - text: "Le DNS est hiérarchique : au sommet se trouvent les serveurs racine,
        suivis des serveurs TLD (.com, .org...), puis des serveurs autoritaires
        responsables des noms de domaine spécifiques."
  utter_differents_serveurs_dns:
    - text: "Il existe plusieurs types de serveurs DNS : le serveur racine, le serveur
        TLD, le serveur autoritaire et le résolveur récursif qui interagit avec
        les autres pour répondre à la requête."
  utter_cache_dns:
    - text: Le DNS utilise le caching pour améliorer les performances. Les résolveurs
        mémorisent les réponses DNS pendant une durée limitée (TTL) pour éviter
        de répéter les requêtes.
  utter_dns_vs_ldap:
    - text: Le DNS permet de résoudre les noms de domaine en adresses IP. LDAP
        (Lightweight Directory Access Protocol) est utilisé pour accéder à des
        services d'annuaire (ex. utilisateurs, ressources).
  utter_service_ldap:
    - text: LDAP est un protocole d'accès aux services d'annuaire. Il permet de
        chercher et modifier des informations hiérarchiques, souvent utilisées
        dans les systèmes de gestion d'utilisateurs.
  utter_relation_dns_annuaire:
    - text: Le DNS est un type de service d'annuaire spécialisé dans la résolution de
        noms de domaine. LDAP est plus général et peut gérer divers types
        d'informations hiérarchiques.
  utter_definition_messagerie_electronique:
    - text: |
        La messagerie électronique est un système permettant de transmettre des
        messages, soit de façon unidirectionnelle (diffusion), soit
        multidirectionnelle (échange entre individus ou groupes), via des
        serveurs et boîtes aux lettres électroniques.
  utter_fonctionnement_messagerie:
    - text: |
        Elle associe un nom d'utilisateur à une boîte aux lettres via un annuaire,
        puis utilise un traitement de texte pour composer le message. Des outils
        comme MIME assurent le codage des messages multimédia.
  utter_protocoles_messagerie:
    - text: |
        Les trois protocoles principaux sont SMTP (envoi entre serveurs), POP3
        (rapatriement local), et IMAP4 (gestion avancée côté client). Chacun
        utilise un port et des états différents.
  utter_smtp_details:
    - text: |
        SMTP fonctionne sur le port 25 via TCP. Les commandes principales sont
        HELO, MAIL, RCPT, DATA et QUIT. Il permet d'envoyer des messages vers
        les boîtes aux lettres des destinataires.
  utter_pop3_details:
    - text: |
        POP3 fonctionne sur le port 110. Il permet à un client de rapatrier ses
        messages et les supprimer du serveur. Il suit trois états :
        autorisation, transaction, mise à jour.
  utter_imap4_details:
    - text: |
        IMAP4 fonctionne sur le port 143. Il gère la boîte aux lettres côté
        serveur. Les états sont : authentification, authentifié, sélection,
        fermeture. Il permet de marquer les messages.
  utter_etiquette_messages:
    - text: |
        Les messages peuvent être marqués comme lus, répondus, importants,
        supprimés, brouillons ou nouveaux, afin de faciliter leur gestion.
  utter_liste_diffusion:
    - text: |
        Une liste de diffusion est une adresse regroupant plusieurs utilisateurs.
        Elle peut être ouverte, contrôlée ou fermée, et éventuellement modérée
        par un responsable.

forms:
  form_demande_technique:
    required_slots: []

  form_troubleshooting:
    required_slots: []

  form_security_audit:
    required_slots: []

  form_cloud_migration:
    required_slots: []

  form_troubleshoot_data_link:
    required_slots: []
actions:
  - action_analyser_performance
  - action_generer_config
  - action_verifier_compatibilite
  - action_simuler_reseau
  - action_optimiser_parametres
  - action_alerte_securite
  - action_creer_ticket
  - action_lancer_scan
  - action_collecter_logs
  - action_analyser_paquets
  - action_generer_rapport
  - action_planifier_migration
  - action_estimer_couts
  - action_verifier_conformite
  - action_tester_connectivite
  - action_auditer_securite
  - action_optimiser_qos
  - action_sauvegarder_config
  - action_restaurer_config
  - action_monitorer_reseau
  # Chapitres 7, 8 et 9
  - action_comparer_protocoles
  - action_expliquer_primitive
  - action_semantic_faq
  - action_set_last_topic
