version: "3.1"

session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true

intents:

  - ask_transport_protocol
  - ask_port
  - ask_list_ports
  - ask_socket
  - ask_checksum
  - ask_tcp_overview
  - ask_bout_en_bout
  - ask_tcp_comparatif_data_link_table
  - ask_tcp_vs_ppp_example
  - ask_tcp_features
  - ask_tcp_segment_format
  - connexion_tcp
  - fermeture_tcp
  - etats_tcp
  - temporisation_tcp
  - algorithmes_tcp
  - ask_algorithm_jacobson
  - ask_algorithm_karn
  - ask_autres_temporisateurs_tcp
  - ask_algorithm_clark_nagle
  - ask_controle_congestion_tcp
  - interface_tcp_application
  - ask_primitive
  - primitive_detail
  - udp_intro
  - udp_services
  - udp_header_structure
  - udp_vs_tcp
  - udp_use_cases
  - transport_protocols_summary
  - tcp_vs_udp
  - tcp_advantages
  - udp_simplicity
  - tcp_throughput
  - tcp_header_format
  - tcp_connection_context
  - tcp_segment_order
  - tcp_multiple_connections
  - tcp_connection_identification
  - tcp_ping_vs_tcp_connection
  - tcp_same_vs_different_networks
  - tcp_netstat_analysis
  - tcp_advanced_statistics
  - ethernet_frame_analysis
  - ethernet_frame_full_analysis

  - affirm

entities:
  - tcp_flag
  - tcp_field
  - segment_size
  - primitive
  - ip_address
  - port_number

slots:
  protocole: 
    type: text
    influence_conversation: false
    mappings:
      - type: from_text

  algorithme:
    type: text
    influence_conversation: false
    mappings:
      - type: from_text

  version_rip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_text

  message_type:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: message_type

  ip_type:
    type: categorical
    values:
      - fixe
      - dynamique
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_type

  duration:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: duration

  tcp_flag:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: tcp_flag

  tcp_field:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: tcp_field

  segment_size:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: segment_size

  primitive:
    type: text
    influence_conversation: true
    mappings:
      - type: from_entity
        entity: primitive

  client_ip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_address

  server_ip:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: ip_address

  client_port:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: port_number

  server_port:
    type: text
    influence_conversation: false
    mappings:
      - type: from_entity
        entity: port_number

  last_topic:
    type: text
    influence_conversation: true
    initial_value: null
    mappings:
      - type: custom
        action: action_set_last_topic




responses:
  utter_context_unsure:
  - text: >
        ğŸ‘ Je suis lÃ  pour tâ€™aider, mais peux-tu prÃ©ciser sur quel sujet tu veux en savoir plus ?

 
  utter_slot_debug:
  - text: "Le slot last_topic vaut : {last_topic}"


  utter_transport_protocol:
  - text: >
      Un protocole de transport fournit une interface permettant aux applications dâ€™accÃ©der aux services du rÃ©seau.

      Voici ses principales fonctions :

      - ğŸ¯ **Identification des applications** : chaque application est identifiÃ©e par un **port** unique, ce qui permet Ã  plusieurs applications de communiquer en mÃªme temps sur une mÃªme machine.

      - ğŸ”Œ **Communication via sockets** : une **socket** associe une adresse IP Ã  un numÃ©ro de port, permettant dâ€™identifier les extrÃ©mitÃ©s de la communication.

      - ğŸ›¡ï¸ **VÃ©rification de lâ€™intÃ©gritÃ©** : pour s'assurer que les donnÃ©es n'ont pas Ã©tÃ© altÃ©rÃ©es pendant la transmission, le protocole utilise un **total de contrÃ´le** (ou *checksum*), une mÃ©thode de dÃ©tection d'erreurs.

      En rÃ©sumÃ©, le protocole de transport agit comme un intermÃ©diaire fiable entre les applications et le rÃ©seau.

      ğŸ‘‰ Souhaites-tu que je tâ€™explique plus en dÃ©tail la notion de **port** ou de **socket** ?

  utter_port:
  - text: >
      ğŸ”¢ **Notion de port**

      Lorsqu'une machine exÃ©cute plusieurs applications en mÃªme temps, il est essentiel de pouvoir identifier clairement Ã  quelle application doivent Ãªtre livrÃ©es les donnÃ©es reÃ§ues. Câ€™est lÃ  quâ€™intervient la notion de **port**.

      Un **port** est un identifiant numÃ©rique qui permet au protocole de transport de savoir pour **quelle application** il travaille. âš ï¸ Attention, cela nâ€™a rien Ã  voir avec les ports physiques dâ€™un commutateur rÃ©seau !

      ğŸ’¡ Sur certains systÃ¨mes dâ€™exploitation, ce numÃ©ro de port peut Ãªtre liÃ© au **PID (Process Identifier)** du processus actif.

      ğŸ“¦ **Plage des ports** :
      - Les numÃ©ros de port sont codÃ©s sur **16 bits**, soit de **0 Ã  65535**.
      - Les ports **0 Ã  1023** sont appelÃ©s **ports bien connus** (*well-known ports*), rÃ©servÃ©s aux services systÃ¨me comme HTTP (80), FTP (21), etc.
      - Les autres ports (au-delÃ  de 1023) sont gÃ©nÃ©ralement utilisÃ©s de maniÃ¨re dynamique par les clients ou pour des applications spÃ©cifiques.

      Ces affectations sont dÃ©finies officiellement par lâ€™**IANA** (*Internet Assigned Numbers Authority*), ce qui facilite la compatibilitÃ© entre les applications et les rÃ©seaux.

      Tu veux que je te montre une liste des ports les plus utilisÃ©s ?

  utter_list_ports:
    - text: >
        ğŸ“˜ Voici une liste de ports couramment utilisÃ©s :

        - 20/21 : FTP (transfert de fichiers)
        - 22 : SSH (connexion sÃ©curisÃ©e Ã  distance)
        - 23 : Telnet (connexion Ã  distance non sÃ©curisÃ©e)
        - 25 : SMTP (envoi dâ€™e-mails)
        - 53 : DNS (rÃ©solution de noms de domaine)
        - 80 : HTTP (navigation web)
        - 110 : POP3 (rÃ©ception dâ€™e-mails)
        - 143 : IMAP (rÃ©ception dâ€™e-mails)
        - 443 : HTTPS (navigation web sÃ©curisÃ©e)

  utter_socket:
  - text: >
      ğŸ”Œ **Notion de socket**

      Une **application** qui utilise TCP ou UDP doit Ãªtre identifiÃ©e de maniÃ¨re unique sur une machine. Pour cela, le systÃ¨me dâ€™exploitation utilise un **socket**, qui est une **paire** :

      ğŸ§© `<adresse IP locale, numÃ©ro de port local>`

      ğŸ‘‰ Cette paire permet dâ€™identifier un **processus local** utilisant un protocole de transport.

      ğŸ“¡ Pour identifier une communication complÃ¨te entre deux applications, on parle de **socket Ã©tendu** avec **5 Ã©lÃ©ments** :

      ğŸ§¾ `<protocole, IP locale, port local ; IP distante, port distant>`

      Ainsi, une connexion TCP peut Ãªtre totalement dÃ©finie avec ces 5 Ã©lÃ©ments, assurant qu'elle est unique sur le rÃ©seau.

      Tu veux un **exemple concret** de socket en TCP ? ğŸ”

  utter_socket_example:
  - text: >
      ğŸ§ª **Exemple de socket en TCP** :

      Imaginons une application cliente (navigateur) qui se connecte Ã  un serveur web.

      - **CÃ´tÃ© client** :
        - Protocole : TCP
        - IP locale : 192.168.1.10
        - Port local : 50534 (choisi dynamiquement)
      
      - **CÃ´tÃ© serveur** :
        - IP distante : 93.184.216.34
        - Port distant : 80 (HTTP)

      ğŸ‘‰ Le socket complet est donc :
      `TCP, 192.168.1.10:50534 ; 93.184.216.34:80`

      Ce couple identifie **uniquement** cette session TCP dans tout lâ€™Internet.


  utter_checksum:
    - text: >
        âœ… **Notion de total de contrÃ´le (checksum)**

        Le **checksum** est une technique de **redondance** utilisÃ©e dans les protocoles TCP et UDP pour **vÃ©rifier l'intÃ©gritÃ© des donnÃ©es** transmises.

        ğŸ§  Il sâ€™agit dâ€™un calcul simple effectuÃ© sur les donnÃ©es du segment (souvent une **somme** des bits ou une **complÃ©mentation bit Ã  bit**) pour dÃ©tecter les erreurs de transmission.

        ğŸ“ Ce **champ de 16 bits** est placÃ© dans lâ€™**en-tÃªte TCP ou UDP**. Sa position exacte dÃ©pend du protocole utilisÃ©.

        ğŸ” Lorsquâ€™un paquet est reÃ§u, le destinataire **recalcule** le checksum et le compare avec celui reÃ§u dans lâ€™en-tÃªte. Sâ€™ils ne correspondent pas âœ les donnÃ©es sont considÃ©rÃ©es comme corrompues.

  utter_ask_tcp_overview:
  - text: >
      ğŸ“¦ **PrÃ©sentation gÃ©nÃ©rale de TCP (Transmission Control Protocol)**

      Le protocole **TCP** est utilisÃ© lorsque les applications ont besoin dâ€™une **communication fiable** entre deux hÃ´tes sur un rÃ©seau. Contrairement Ã  IP, il corrige ses principales lacunes en offrant les services suivants :

      ğŸ”„ **FiabilitÃ©** : dÃ©tection et correction des erreurs lors de la transmission  
      ğŸš¦ **ContrÃ´le de flux** : Ã©vite la surcharge du rÃ©cepteur  
      ğŸ” **ContrÃ´le de la connexion** : Ã©tablit et maintient une communication cohÃ©rente entre les deux extrÃ©mitÃ©s  

      ğŸ§± TCP fonctionne avec une unitÃ© appelÃ©e **segment**. Voici comment Ã§a marche :

      - Pour envoyer un segment :  
        ğŸ‘‰ Le module TCP appelle IP avec une **RequÃªte_Ã©mission(segment, adresse IP distante)**  
      
      - Pour recevoir un segment :  
        ğŸ‘‰ Le module IP signale TCP avec une **Indication_rÃ©ception(segment reÃ§u, adresse IP source)**  

      L'interface TCP/IP est simple, mais celle entre TCP et les **applications utilisatrices** est plus complexe. On lâ€™Ã©tudiera aprÃ¨s avoir vu le **format du segment TCP** et le **cycle de vie dâ€™une connexion**.

      â• **Souhaitez-vous que je vous explique :**
      - ğŸ§ª **Le fonctionnement de TCP Ã©tape par Ã©tape** (Ã©tablissement, transfert, fermeture) ?
      - ğŸ§° **Les primitives utilisÃ©es** dans les Ã©changes TCP ?
      - ğŸ“„ **Le format dâ€™un segment TCP** avec ses champs ?

  utter_bout_en_bout:
  - text: >
      ğŸ”„ **Connexion de bout en bout en TCP**

      TCP fonctionne selon un modÃ¨le de **dialogue de bout en bout** :  
      ğŸ“¡ Une connexion est Ã©tablie **directement entre les deux hÃ´tes terminaux** â€” pas entre les routeurs, commutateurs ou autres Ã©quipements intermÃ©diaires.

      ğŸ“œ DÃ©crit dans la [RFC 793](https://datatracker.ietf.org/doc/html/rfc793), TCP permet Ã  deux applications distantes dâ€™Ã©changer des donnÃ©es de maniÃ¨re **fiable et ordonnÃ©e**, peu importe le chemin que les paquets prennent Ã  travers le rÃ©seau.

      âš™ï¸ Pour cela :
      - Une **connexion** est Ã©tablie Ã  la demande dâ€™une application (via le **3-way handshake**)  
      - Un **contexte de connexion** est crÃ©Ã© et maintenu des deux cÃ´tÃ©s (paramÃ¨tres nÃ©gociÃ©s, Ã©tat de la communication, temporisations, etc.)  
      - Cette connexion est **gÃ©rÃ©e entiÃ¨rement par les hÃ´tes** (ordinateurs, serveursâ€¦), **jamais par les routeurs** intermÃ©diaires

      ğŸ’¬ Ce mode connectÃ© signifie que :
      - Les deux extrÃ©mitÃ©s doivent Ãªtre prÃªtes Ã  communiquer  
      - Une demande doit Ãªtre acceptÃ©e pour que la communication dÃ©marre  
      - On parle alors de **la vie de la connexion TCP**

      â• Tu veux que je t'explique :
      - ğŸ” **Le cycle de vie complet d'une connexion TCP** ?
      - ğŸ§  **Comment le contexte de connexion est gÃ©rÃ© dans TCP** ?
      - ğŸ“¶ **La diffÃ©rence entre la fiabilitÃ© TCP et le fonctionnement d'IP sans connexion** ?


  utter_tcp_features:
  - text: >
      âš™ï¸ **FonctionnalitÃ©s avancÃ©es de TCP**

      TCP offre un service de transport **fiable et ordonnÃ©**, en sâ€™appuyant sur plusieurs mÃ©canismes clÃ©s :

      ğŸ”¢ **NumÃ©rotation octet par octet**  
      Chaque octet est numÃ©rotÃ© pour permettre la dÃ©tection de pertes ou de duplications, et la remise en ordre Ã  la rÃ©ception.

      âœ… **Acquittements**  
      Lâ€™Ã©metteur attend un accusÃ© de rÃ©ception pour chaque sÃ©quence de donnÃ©es envoyÃ©e. Cela permet de retransmettre les segments perdus.

      ğŸªŸ **FenÃªtre dâ€™anticipation (Sliding Window)**  
      - GÃ¨re la quantitÃ© de donnÃ©es quâ€™un Ã©metteur peut envoyer sans attendre dâ€™acquittement.  
      - DÃ©pend de la capacitÃ© du tampon de rÃ©ception de lâ€™autre hÃ´te.  
      - Sa taille est dynamique, ajustÃ©e selon la bande passante estimÃ©e en cours de communication.

      â±ï¸ **Temporisateurs adaptatifs**  
      - Le temps dâ€™attente pour un acquittement est ajustÃ© dynamiquement en fonction des dÃ©lais observÃ©s sur le rÃ©seau.  
      - Cela rend TCP plus efficace dans des rÃ©seaux variables.

      ğŸš¨ **DonnÃ©es urgentes (urgent data)**  
      TCP peut transmettre certaines donnÃ©es Â« urgentes Â» sans les soumettre au contrÃ´le de flux classique.

      ğŸ” **Comparaison avec la couche liaison OSI**  
      Comme en liaison de donnÃ©es, TCP gÃ¨re :  
      - Le sÃ©quencement  
      - Le contrÃ´le de flux  
      - La dÃ©tection et la correction des erreurs  
      Mais Ã  la diffÃ©rence de la couche liaison, TCP agit **entre des hÃ´tes distants** Ã  travers un rÃ©seau potentiellement instable et multiple.

      â• Souhaitez-vous explorer :
      - ğŸªŸ La **gestion dÃ©taillÃ©e de la fenÃªtre glissante** ?
      - â±ï¸ Le **fonctionnement des temporisateurs adaptatifs** ?
      - ğŸš¨ Ou comment sont traitÃ©es les **donnÃ©es urgentes en TCP** ?
      - ğŸ“Š Un tableau comparatif entre TCP et un protocole comme HDLC ou PPP ?
      - ğŸ” Un exemple concret illustrant les diffÃ©rences de comportement ?


  utter_tcp_comparatif_data_link_table:
    - text: >
        ğŸ“Š Voici un tableau comparatif simplifiÃ© :

        | Fonction               | Liaison (ex. : PPP)         | Transport (TCP)             |
        |------------------------|-----------------------------|-----------------------------|
        | Couche OSI             | 2 â€“ Liaison de donnÃ©es      | 4 â€“ Transport               |
        | Type de communication | Direct (support physique)   | Bout en bout (via IP)       |
        | Adressage              | MAC                         | IP + Port                   |
        | ContrÃ´le de flux       | Oui                         | Oui                         |
        | RÃ©Ã©mission             | Locale                      | Bout en bout                |
        | Nbre de connexions     | 1 souvent                   | Plusieurs simultanÃ©es       |
        | Ordre des donnÃ©es      | Garanti par le support      | Doit Ãªtre restaurÃ©          |

        â• Tu veux quâ€™on applique Ã§a Ã  un scÃ©nario concret (comme un tÃ©lÃ©chargement FTP) ?

  utter_tcp_vs_ppp_example:
    - text: >
        ğŸ” Imaginons un fichier tÃ©lÃ©chargÃ© depuis Internet :

        - **PPP (liaison)** : gÃ¨re les trames entre ton ordinateur et ton routeur, sur la ligne ADSL ou fibre.
        - **TCP (transport)** : gÃ¨re la fiabilitÃ© de lâ€™Ã©change **entre ton PC et le serveur distant**, mÃªme Ã  travers plusieurs routeurs.



  utter_tcp_segment_format:
  - text: >
      ğŸ“¦ Le **segment TCP** contient un en-tÃªte structurÃ© suivi Ã©ventuellement de **donnÃ©es**.

      Voici les principaux champs de lâ€™en-tÃªte TCP (sans options) :

      ğŸ”¹ **Port source** (16 bits) : identifie lâ€™application cÃ´tÃ© Ã©metteur  
      ğŸ”¹ **Port destination** (16 bits) : identifie lâ€™application cÃ´tÃ© rÃ©cepteur  
      ğŸ”¹ **NumÃ©ro de sÃ©quence** (32 bits) : identifie le premier octet de donnÃ©es envoyÃ©es  
      ğŸ”¹ **NumÃ©ro dâ€™accusÃ© de rÃ©ception** (32 bits) : indique le prochain octet attendu  
      ğŸ”¹ **Longueur dâ€™en-tÃªte (Data Offset)** (4 bits) : longueur de lâ€™en-tÃªte TCP (en mots de 32 bits)  
      ğŸ”¹ **RÃ©servÃ©** (6 bits) : rÃ©servÃ© pour des usages futurs  
      ğŸ”¹ **Drapeaux (flags)** (6 bits) : contrÃ´lent la communication :
          - URG : donnÃ©es urgentes  
          - ACK : acquittement  
          - PSH : envoi immÃ©diat aux applications  
          - RST : rÃ©initialisation de la connexion  
          - SYN : ouverture de connexion  
          - FIN : fermeture de connexion  
      ğŸ”¹ **FenÃªtre** (16 bits) : taille de la fenÃªtre de rÃ©ception (contrÃ´le de flux)  
      ğŸ”¹ **Total de contrÃ´le (Checksum)** (16 bits) : vÃ©rifie lâ€™intÃ©gritÃ© du segment  
      ğŸ”¹ **Pointeur dâ€™urgence** (16 bits) : indique la position des donnÃ©es urgentes  
      ğŸ”¹ **Options** (taille variable) : permettent dâ€™ajouter des fonctionnalitÃ©s comme :
          - **MSS (Maximum Segment Size)** : taille max des segments acceptÃ©s  
          - **Timestamp** : mesure du RTT (temps aller-retour)  
          - **Window Scale** : extension de la taille de la fenÃªtre (> 65 535 octets)  
          - **SACK permitted** : permet les acquittements sÃ©lectifs  
      ğŸ”¹ **Remplissage (padding)** : aligne lâ€™en-tÃªte sur un multiple de 4 octets  
      ğŸ”¹ **DonnÃ©es** : transport de l'information de lâ€™application (et donnÃ©es urgentes si URG)

      ğŸ§ª Exemple : Sur un rÃ©seau Ethernet, la MSS vaut souvent **1460 octets** (1500 - 40 dâ€™en-tÃªtes IP + TCP)

      ğŸ” Souhaitez-vous une reprÃ©sentation graphique de ce segment TCP ou une explication via un exemple Wireshark ?

  utter_connexion_tcp:
  - text: >
      ğŸ” **Ouverture dâ€™une connexion TCP : le Three-Way Handshake**

      Une connexion TCP dÃ©bute par une procÃ©dure en **trois Ã©tapes** entre un **client** et un **serveur**, appelÃ©e *three-way-handshake* :

      1ï¸âƒ£ Le **client** initie la connexion avec un segment contenant le drapeau `SYN=1` et un **numÃ©ro de sÃ©quence initial** `nseqE = x`.

      2ï¸âƒ£ Le **serveur**, aprÃ¨s une ouverture passive, rÃ©pond avec un segment `SYN=1, ACK=1`, contenant :
         - `nseqE = y` (son propre numÃ©ro de sÃ©quence initial)
         - `nseqR = x + 1` (accusÃ© de rÃ©ception du SYN du client)

      3ï¸âƒ£ Le **client** finalise lâ€™ouverture avec un segment `ACK=1` :
         - `nseqE = x + 1`
         - `nseqR = y + 1` (accusÃ© de rÃ©ception du SYN du serveur)

      âœ… Ã€ lâ€™issue de ces 3 Ã©changes, la connexion est Ã©tablie : les deux parties connaissent les numÃ©ros de sÃ©quence de dÃ©part et peuvent commencer Ã  transmettre des donnÃ©es de maniÃ¨re fiable.

      âš™ï¸ **SchÃ©ma de lâ€™Ã©change :**

      ```
      Client  â†’  SYN, nseqE = x, nseqR = 0
      Serveur â†  SYN, ACK, nseqE = y, nseqR = x+1
      Client  â†’  ACK, nseqE = x+1, nseqR = y+1
      ```

      ğŸ§­ Le client doit connaÃ®tre Ã  lâ€™avance le **numÃ©ro de port** de lâ€™application serveur. Les ports standards sont souvent utilisÃ©s (ex : 80 pour HTTP, 443 pour HTTPS), mais des ports personnalisÃ©s sont possibles.

      ğŸ‘‰ Ce mÃ©canisme assure une **synchronisation fiable** entre les deux hÃ´tes avant tout Ã©change de donnÃ©es.

      Voulez-vous une explication sur le mÃ©canisme de fermeture ?

  utter_fermeture_tcp:
    - text: >
        ğŸ”š *Fermeture dâ€™une connexion TCP*

        La fermeture d'une connexion TCP suit un processus en **quatre Ã©tapes**, car une connexion TCP est **bidirectionnelle** : chaque sens doit Ãªtre fermÃ© indÃ©pendamment.

        ğŸ§© *Ã‰tapes de la fermeture normale* :
        1. Un cÃ´tÃ© (client ou serveur) envoie un segment avec le drapeau `FIN = 1` pour indiquer qu'il a terminÃ© l'envoi de donnÃ©es.
        2. L'autre cÃ´tÃ© rÃ©pond avec un segment `ACK`, accusant rÃ©ception du FIN.
        3. Ensuite, le second cÃ´tÃ© envoie son propre segment `FIN` pour signaler quâ€™il a aussi terminÃ© lâ€™envoi de ses donnÃ©es.
        4. Le premier cÃ´tÃ© rÃ©pond Ã  son tour avec un `ACK`, complÃ©tant ainsi la fermeture.

        â• Chaque flux est fermÃ© sÃ©parÃ©ment, ce qui explique pourquoi **quatre segments sont nÃ©cessaires** (contrairement aux trois lors de l'ouverture).

        âš ï¸ *Fermeture brutale (RST)* :
        En cas de problÃ¨me (ex. fermeture inattendue d'une application), un module TCP peut envoyer un segment avec `RST = 1`.
        - Ce segment peut contenir les derniers octets en attente.
        - Aucun `ACK` nâ€™est attendu.
        - Le destinataire traite les donnÃ©es restantes, puis signale une **fin anormale** de la connexion Ã  lâ€™application.

  
  utter_etats_tcp:
    - text: >
        TCP utilise un automate Ã  11 Ã©tats pour gÃ©rer les connexions. Parmi les Ã©tats : LISTEN, SYN_SENT,
        ESTABLISHED, FIN_WAIT, TIME_WAIT, etc. Ces Ã©tats reprÃ©sentent les diffÃ©rentes Ã©tapes d'Ã©tablissement,
        de transfert de donnÃ©es et de fermeture d'une connexion TCP.

        On voit que lâ€™ouverture et la fermeture dâ€™une connexion dÃ©pendent de nombreux Ã©vÃ©nements et peuvent conduire Ã  beaucoup de situations diffÃ©rentes.
        Une reprÃ©sentation commode des Ã©tapes de lâ€™Ã©tablissement et de la libÃ©ration dâ€™une connexion TCP se fait en utilisant un automate dâ€™Ã©tats finis Ã  onze Ã©tats (voir tableau 7.2).
        Dans chaque Ã©tat, seuls certains Ã©vÃ©nements sont autorisÃ©s et une action prÃ©cise est entreprise.
        Dans le cas oÃ¹ lâ€™Ã©vÃ©nement nâ€™est pas autorisÃ©, on renvoie un signal dâ€™erreur.

        La figure suivante donne les transitions dâ€™Ã©tats de lâ€™automate dâ€™une connexion TCP :
      image: "https://ibb.co/sJpKsfPL.png"

  utter_temporisation_tcp:
    - text: >
        TCP utilise des temporisateurs pour assurer la fiabilitÃ© des transmissions. Ã€ chaque envoi de segment, un minuteur est dÃ©clenchÃ©. 
        Si lâ€™accusÃ© de rÃ©ception (ACK) nâ€™est pas reÃ§u avant lâ€™expiration de ce dÃ©lai, TCP considÃ¨re le segment comme perdu et le retransmet.

        Pour gÃ©rer cette temporisation, TCP mesure le RTT (Round Trip Time), câ€™est-Ã -dire le temps aller-retour entre lâ€™envoi dâ€™un segment 
        et la rÃ©ception de son acquittement. Ce dÃ©lai peut fortement varier selon la distance, la qualitÃ© du rÃ©seau et le trafic.

        Par exemple :
        - ping 192.168.0.2 âŸ¶ RTT â‰ˆ 6 ms (rÃ©seau local)
        - ping 203.50.4.178 âŸ¶ RTT â‰ˆ 358 ms (vers lâ€™Australie)

        GrÃ¢ce Ã  ces mesures dynamiques, TCP ajuste automatiquement ses temporisations pour optimiser la fiabilitÃ© et lâ€™efficacitÃ© des transferts.
  
  utter_algorithmes_tcp:
    - text: >
        TCP implÃ©mente plusieurs algorithmes comme celui de Jacobson pour ajuster les temporisations
        avec RTT estimÃ© et Ã©cart de variation (D). L'algorithme de Karn Ã©vite l'ambiguÃ¯tÃ© des acquittements
        en ignorant les RTT des segments retransmis. Clark et Nagle rÃ©duisent l'envoi de petits segments
        inutiles, amÃ©liorant l'efficacitÃ© dans les communications interactives.
  
  

  utter_algorithm_jacobson:
    - text: >
        Lâ€™algorithme de Jacobson est utilisÃ© par TCP pour ajuster dynamiquement la temporisation (timeout) en fonction des conditions du rÃ©seau.

        âš™ï¸ Pourquoi câ€™est nÃ©cessaire ?
        Si la temporisation est trop courte â†’ retransmissions inutiles.  
        Si elle est trop longue â†’ performances dÃ©gradÃ©es.  
        Il faut donc une estimation **prÃ©cise et adaptative** du dÃ©lai dâ€™attente.

        ğŸ“ Lâ€™idÃ©e de Jacobson :
        On mesure en continu le RTT (Round Trip Time), câ€™est-Ã -dire le temps entre lâ€™envoi dâ€™un segment TCP et la rÃ©ception de son ACK.
        Pour Ã©viter de rÃ©agir Ã  de simples variations momentanÃ©es, on utilise une **moyenne pondÃ©rÃ©e** :

        RTT_estimÃ© = a Ã— RTT_estimÃ© + (1 â€“ a) Ã— Nouveau_RTT  
        â¤ Avec a â‰ˆ 7/8, donc plus de poids au passÃ© pour lisser les fluctuations.

        ğŸ§® Ensuite, on Ã©value la **variabilitÃ©** du RTT avec une estimation dâ€™Ã©cart :

        D = (1 â€“ a) Ã— |RTT_estimÃ© â€“ Nouveau_RTT|

        ğŸ•“ Enfin, on fixe la temporisation avec une marge de sÃ©curitÃ© proportionnelle Ã  la variabilitÃ© :

        Temporisation = RTT_estimÃ© + 4 Ã— D

        âœ… RÃ©sultat : une temporisation adaptative, plus longue quand le rÃ©seau est instable, plus courte quand il est stable.

  

  utter_algo_karn:
    - text: >
        ğŸ”„ **Algorithme de Karn** (TCP) :  
        Il rÃ©sout un problÃ¨me dâ€™ambiguÃ¯tÃ© liÃ© aux accusÃ©s de rÃ©ception (ACK) lorsque des segments sont retransmis.

        ğŸ“Œ ProblÃ¨me :
        Lorsquâ€™un segment est retransmis, on ne peut pas savoir si lâ€™ACK reÃ§u correspond au segment original ou au retransmis. Cela fausse le calcul du RTT (Round Trip Time) si on le met Ã  jour dans ce contexte.

        âœ… Solution (algorithme de Karn) :
        - **Ignorer** les mesures de RTT pour les segments retransmis.
        - **Conserver** la temporisation prÃ©cÃ©dente.
        - **Augmenter** la temporisation en cas de nouvelle expiration :
          Nouvelle temporisation = g Ã— Temporisation (avec g â‰ˆ 2, stratÃ©gie de backoff).

        ğŸ§  Avantage :  
        Cela Ã©vite de fausser la mesure du RTT et limite les surÃ©valuations entraÃ®nant des dÃ©lais excessifs.

        Voulez-vous d'autres que je donne d'autres temporisateurs utilisÃ©s par TCP ?

  

  utter_autres_temporisateurs_tcp:
    - text: >
        â±ï¸ **Autres temporisateurs utilisÃ©s par TCP** :

        1. **Temporisateur de persistance** :
        - Ã‰vite le blocage mutuel quand le rÃ©cepteur a une fenÃªtre de rÃ©ception nulle.
        - Il envoie des "probes" pour vÃ©rifier si la fenÃªtre est rÃ©ouverte.

        2. **Temporisateur de limitation dâ€™attente (keep-alive)** :
        - VÃ©rifie si la connexion est toujours active aprÃ¨s une longue pÃ©riode dâ€™inactivitÃ©.
        - Peut entraÃ®ner une fermeture si aucune rÃ©ponse nâ€™est reÃ§ue.

        3. **Temporisateur TIME-WAIT** :
        - UtilisÃ© aprÃ¨s la fermeture dâ€™une connexion.
        - Dure 2 fois la durÃ©e de vie maximale dâ€™un segment pour garantir quâ€™aucun segment rÃ©siduel ne subsiste sur le rÃ©seau.

        ğŸ“¦ Ces temporisateurs amÃ©liorent la fiabilitÃ©, la robustesse et la gestion efficace des ressources TCP.

  

  utter_algorithm_clark_nagle:
    - text: >
        ğŸ“‰ **Syndrome de la fenÃªtre stupide (Silly Window Syndrome)** :
        Ce problÃ¨me survient lorsque lâ€™Ã©metteur envoie de tout petits segments de donnÃ©es, souvent un octet Ã  la fois,
        ce qui sature inutilement le rÃ©seau et dÃ©grade les performances de TCP.

        ğŸ§  **Solution â€” Algorithme de Clark (cÃ´tÃ© rÃ©cepteur)** :
        - Le rÃ©cepteur nâ€™annonce pas une mise Ã  jour de fenÃªtre pour de trÃ¨s petites tailles (comme 1 octet).
        - Il attend soit :
          - que le tampon soit Ã  moitiÃ© vide, **ou**
          - quâ€™un segment de taille maximale puisse Ãªtre reÃ§u.
        âœ… Cela rÃ©duit le nombre de mises Ã  jour inutiles et Ã©vite dâ€™encourager lâ€™envoi de petits segments.

        ğŸš€ **Solution â€” Algorithme de Nagle (cÃ´tÃ© Ã©metteur)** :
        - Lâ€™Ã©metteur envoie **le premier octet seul**, puis attend son acquittement.
        - Ensuite, il accumule les donnÃ©es dans un tampon et les envoie toutes dâ€™un coup.
        - Cette mÃ©thode Ã©vite dâ€™inonder le rÃ©seau avec des segments minuscules.

        ğŸ§© **ComplÃ©mentaritÃ©** :
        - Ces deux algorithmes sont **compatibles et souvent utilisÃ©s ensemble**.
        - Clark Ã©vite les petites fenÃªtres cÃ´tÃ© rÃ©cepteur.
        - Nagle Ã©vite les petits envois cÃ´tÃ© Ã©metteur.

        ğŸ“Š **Objectif commun** :
        - RÃ©duire la surcharge rÃ©seau due aux petits paquets,
        - Optimiser les performances TCP, en particulier pour les applications interactives comme les sessions SSH ou Telnet.

  

  utter_controle_congestion_tcp:
    - text: >
        ğŸ“¶ **ContrÃ´le de congestion TCP** :
        TCP utilise un algorithme adaptatif pour Ã©viter la saturation du rÃ©seau. Il ajuste dynamiquement
        la **fenÃªtre de congestion (congestion window)** en fonction des accusÃ©s de rÃ©ception (ACK) et des
        expirations de temporisation (timeouts).

        ğŸ“Œ **Fonctionnement global** :
        TCP maintient deux fenÃªtres :
        - La **fenÃªtre de rÃ©ception** (donnÃ©e par le rÃ©cepteur),
        - La **fenÃªtre de congestion** (gÃ©rÃ©e par lâ€™Ã©metteur pour Ã©viter de surcharger le rÃ©seau).

        Lâ€™expÃ©diteur ne peut envoyer quâ€™un nombre dâ€™octets Ã©gal au **minimum** de ces deux fenÃªtres.

        ğŸš€ **Phase 1 â€“ DÃ©marrage lent (Slow Start)** :
        - La taille de la fenÃªtre de congestion commence Ã  1 MSS (Maximum Segment Size).
        - Ã€ chaque ACK reÃ§u, la taille double (croissance **exponentielle**).
        - Cette croissance continue jusquâ€™Ã  atteindre un seuil appelÃ© **"seuil dâ€™Ã©vitement de congestion" (ssthresh)**.

        âš ï¸ **DÃ©tection de congestion (Timeout)** :
        - Si un segment nâ€™est pas acquittÃ© Ã  temps, on considÃ¨re quâ€™il y a congestion.
        - Le seuil est alors fixÃ© Ã  la moitiÃ© de la fenÃªtre courante.
        - La fenÃªtre de congestion est **rÃ©initialisÃ©e Ã  1 MSS**.

        ğŸ“‰ **Phase 2 â€“ Ã‰vitement de congestion (Congestion Avoidance)** :
        - DÃ¨s que la fenÃªtre atteint `ssthresh`, la croissance devient **linÃ©aire** : +1 MSS par fenÃªtre rÃ©ussie.
        - Cela permet de stabiliser lâ€™envoi de donnÃ©es et de prÃ©venir la surcharge du rÃ©seau.
      
        ğŸ“Š **Illustration (figure)** :
        - ğŸ“ˆ De 0 Ã  8 : croissance exponentielle (Slow Start).
        - ğŸŸ¥ Ã€ 13 : **perte de segment** â†’ timeout â†’ rÃ©initialisation.
        - ğŸ“‰ De 14 Ã  24 : croissance **linÃ©aire** (Congestion Avoidance), aprÃ¨s une nouvelle croissance exponentielle jusquâ€™au seuil.

        ğŸ§  **Conclusion** :
        Ce mÃ©canisme permet Ã  TCP de dÃ©tecter et rÃ©agir Ã  la congestion **sans surcharge excessive du rÃ©seau**,
        en adaptant dynamiquement sa vitesse dâ€™envoi en fonction des retours du rÃ©seau.

      image: "https://ibb.co/sJpKsfPL.png"


  utter_interface_tcp_application:
    - text: >
        ğŸ§© **Interface entre TCP et l'application** :

        Les processus applicatifs communiquent via **des sockets TCP**, une abstraction logicielle
        qui permet dâ€™envoyer et de recevoir des donnÃ©es Ã  travers une connexion rÃ©seau fiable.

        ğŸ”§ **CÃ´tÃ© serveur** :
        - `socket()` : crÃ©ation de la socket.
        - `bind()` : association Ã  une adresse IP et un numÃ©ro de port.
        - `listen()` : mise en attente des connexions entrantes.
        - `accept()` : accepte une connexion entrante et crÃ©e une nouvelle socket dÃ©diÃ©e.

        ğŸ–¥ï¸ **CÃ´tÃ© client** :
        - `socket()` : crÃ©ation de la socket.
        - `connect()` : demande de connexion Ã  un serveur (initie la connexion TCP).

        ğŸ”„ **Ã‰change de donnÃ©es** :
        - `read()` / `write()` : primitives standards pour lire et Ã©crire dans la socket.
        - ou bien `recv()` / `send()` : Ã©quivalents souvent utilisÃ©s.
        - parfois `recvfrom()` / `sendto()` : surtout pour UDP, mais utilisables selon lâ€™implÃ©mentation.

        âŒ **Fermeture de la connexion** :
        - `close()` : termine la connexion cÃ´tÃ© client (**fermeture active**) ou cÃ´tÃ© serveur (**fermeture passive**).

        âš™ï¸ Ces primitives permettent aux applications client/serveur de **gÃ©rer la communication rÃ©seau** sans avoir Ã  manipuler les dÃ©tails internes de TCP.

  utter_ask_primitive:
    - text: "Quelle primitive veux-tu que je dÃ©taille ? Bind, Listen, Connect, Accept, Read, Write, Close, etc. ?"

  utter_udp_intro:
    - text: >
        UDP est un protocole de transport sans connexion, simple et rapide,
        qui n'assure ni fiabilitÃ©, ni ordre de livraison, ni vÃ©rification d'erreurs complexes.
        Il fonctionne sans Ã©tablissement de connexion prÃ©alable.

  utter_udp_services:
    - text: >
        UDP fournit un service minimal efficace, adaptÃ© aux applications temps rÃ©el,
        comme le streaming, les jeux en ligne ou les services DNS et SNMP.

  utter_udp_header_structure:
    - text: >
        L'en-tÃªte UDP comprend 4 champs : port source, port destination, longueur et checksum,
        sur un total de 8 octets.

  utter_udp_vs_tcp:
    - text: >
        Contrairement Ã  TCP, UDP ne garantit pas la fiabilitÃ© ni l'ordre de livraison.
        Il est plus rapide mais moins robuste, et il n'impose pas de surcharge de gestion.

  utter_primitive_detail:
    - text: >
        La primitive {primitive} permet d'interagir avec les sockets UDP.
        Pour plus de dÃ©tails, consulte la documentation de ton OS ou la base de donnÃ©es.

  utter_udp_use_cases:
    - text: >
        UDP est utilisÃ© dans les applications qui tolÃ¨rent les pertes de donnÃ©es :
        DNS, SNMP, RIP, les jeux en rÃ©seau et le streaming vidÃ©o/audio.

  utter_transport_protocols_summary:
    - text: >
        Deux protocoles de transport sont utilisÃ©s : TCP, fiable et complexe, pour les Ã©changes importants ; et UDP, simple et rapide, adaptÃ© aux applications avec contraintes de temps.

  utter_tcp_vs_udp:
    - text: >
        TCP est utilisÃ© pour les Ã©changes fiables et volumineux, tandis qu'UDP convient aux communications rapides et simples oÃ¹ la perte de donnÃ©es est tolÃ©rable.

  utter_tcp_advantages:
    - text: >
        TCP assure la fiabilitÃ© des Ã©changes avec des mÃ©canismes de contrÃ´le d'erreurs, de sÃ©quence, de flux et de congestion, ce qui le rend indispensable pour les applications critiques.

  utter_udp_simplicity:
    - text: >
        UDP est plus lÃ©ger que TCP, sans gestion de connexion ni de fiabilitÃ©, ce qui le rend utile pour les applications temps rÃ©el comme le streaming ou les jeux en ligne.

  utter_tcp_throughput:
    - text: >
        Sur Ethernet Ã  10 Mbit/s, en tenant compte des 40 octets d'en-tÃªte IP et TCP, 
        le dÃ©bit utile maximal est environ 9,55 Mbit/s pour 1460 octets utiles sur 1528 transmis.

  utter_tcp_header_format:
    - text: >
        TCP utilise un seul format de segment pour simplifier le traitement, optimiser les performances 
        et permettre une implÃ©mentation cohÃ©rente pour tous les types de communication (connexion, transfert, fermeture).

  utter_tcp_connection_context:
    - text: >
        Le mode connectÃ© permet Ã  TCP de gÃ©rer un contexte de communication, avec contrÃ´le de flux, 
        correction d'erreurs, numÃ©rotation, et adaptation dynamique aux conditions du rÃ©seau.

  utter_tcp_segment_order:
    - text: >
        Comme IP ne garantit pas l'ordre des datagrammes, TCP numÃ©rote les octets et rÃ©ordonne les segments 
        Ã  la rÃ©ception pour assurer la cohÃ©rence des donnÃ©es pour l'application.

  utter_tcp_multiple_connections:
    - text: >
        Oui, TCP peut gÃ©rer plusieurs connexions en parallÃ¨le, chaque connexion Ã©tant identifiÃ©e par une paire 
        unique de sockets (adresse IP et numÃ©ro de port pour l'Ã©metteur et le rÃ©cepteur).

  utter_tcp_connection_identification:
    - text: >
        Le port Ã©levÃ© ({client_port}) indique que la machine {client_ip} est probablement un client. 
        Le port bas ({server_port}), ici typique d'un serveur Web (port 80), indique que {server_ip} est le serveur.
        Les adresses IP appartenant Ã  des rÃ©seaux diffÃ©rents impliquent qu'un ou plusieurs routeurs sont traversÃ©s.

  utter_tcp_ping_vs_tcp_connection:
    - text: >
        Bien que votre connexion TCP soit active (Ã©tat ESTABLISHED), il est possible que la machine distante ou un routeur intermÃ©diaire filtre les requÃªtes ICMP (utilisÃ©es par la commande ping) pour des raisons de sÃ©curitÃ©. 
        Ainsi, l'absence de rÃ©ponse au ping ne signifie pas nÃ©cessairement que la machine est hors service. Votre application peut continuer Ã  fonctionner normalement.

  utter_tcp_same_vs_different_networks:
    - text: >
        TCP fonctionne de la mÃªme maniÃ¨re que les machines soient sur le mÃªme rÃ©seau ou sur des rÃ©seaux diffÃ©rents.
        Dans les deux cas, un segment TCP est encapsulÃ© dans un datagramme IP contenant les adresses IP source et destination.
        La diffÃ©rence rÃ©side dans le traitement au niveau des couches infÃ©rieures : sur un mÃªme rÃ©seau, la trame contient directement les adresses MAC des deux machines.
  utter_tcp_netstat_analysis:
    - text: >
        Lâ€™analyse des statistiques netstat montre que 7 connexions TCP sont actuellement actives.
        Le trafic est bien Ã©quilibrÃ© entre les segments envoyÃ©s et reÃ§us. Le nombre trÃ¨s faible de retransmissions (10 sur plus de 107 000 segments envoyÃ©s)
        indique une bonne qualitÃ© de transmission, avec un taux dâ€™erreur trÃ¨s bas, de lâ€™ordre de 2*10â»â¸ si lâ€™on considÃ¨re une taille typique de segment TCP.
        Les "ouvertures actives" correspondent aux connexions initiÃ©es par la machine, et les "ouvertures passives" Ã  celles reÃ§ues.

  utter_tcp_advanced_statistics:
    - text: >
        Les statistiques montrent une activitÃ© rÃ©seau typique dâ€™un serveur :
        les segments envoyÃ©s sont en moyenne de 1388 octets, tandis que ceux reÃ§us sont bien plus petits (135 octets),
        ce qui suggÃ¨re que cette machine envoie de gros volumes de donnÃ©es et reÃ§oit peu (probablement des requÃªtes).
        91% des paquets reÃ§us contiennent des acquittements (ACK), chacun validant environ 2,33 Ko de donnÃ©es.
        Les pertes de segments sont probablement dues Ã  la congestion ou lâ€™instabilitÃ© rÃ©seau.
        Les paquets "window update" et "window probe" servent Ã  ajuster dynamiquement la fenÃªtre TCP.
        Les paquets de contrÃ´le sont utilisÃ©s pour gÃ©rer l'ouverture et la fermeture des connexions.
        Sur 356 demandes de connexion, seules 92 ont Ã©tÃ© acceptÃ©es (75% d'Ã©chec), probablement Ã  cause dâ€™un contrÃ´le dâ€™accÃ¨s (login/mot de passe).
        Le volume moyen Ã©mis par connexion est de 5 Mo, contre 24 Ko reÃ§us.
        Le RTT a Ã©tÃ© mis Ã  jour frÃ©quemment (86% des cas), mais il y a eu trÃ¨s peu dâ€™expirations de timeout (21),
        et aucun abandon dÃ» au mÃ©canisme Keepalive : les connexions sont donc stables et bien gÃ©rÃ©es.

  utter_ethernet_frame_analysis:
    - text: >
        Cette trame Ethernet commence par un prÃ©ambule de synchronisation suivi de :
        - Adresse MAC destination : AA:AA:AA:AA:AA:AA
        - Adresse MAC source : AA:AB:08:00:20:0A
        - Type : 0x7000 (valide si taille < 1500 â†’ câ€™est une trame Ethernet II contenant un datagramme IP).
        
        Ensuite, lâ€™en-tÃªte IP (20 octets) est dÃ©taillÃ© :
        - Version : 4, Longueur en-tÃªte : 5 mots (20 octets)
        - Longueur totale du datagramme : 40 octets
        - Identification : A6F5
        - Pas de fragmentation (DF=1, MF=0)
        - TTL : 26
        - Protocole : 6 (TCP)
        - IP source : 192.93.2.1
        - IP destination : 132.227.61.5
        - Somme de contrÃ´le IP : 7594

        Lâ€™en-tÃªte TCP (20 octets) contient :
        - Port source : 21 (FTP)
        - Port destination : 3975
        - NumÃ©ros de sÃ©quence et dâ€™ACK valides
        - Flags SYN et ACK Ã  1 â†’ rÃ©ponse positive Ã  une requÃªte de connexion
        - FenÃªtre : 4 096 octets

        Enfin, il y a 6 octets de bourrage (valeurs : 20 20 20 20 20 20) pour complÃ©ter la trame Ethernet au minimum de 64 octets.

        Trame complÃ¨te correcte pour une initialisation de connexion FTP.

  utter_ethernet_frame_full_analysis:
    - text: >
        La trame Ethernet commence par :
        - Synchronisation : AA AA AA AA AA AA AA AB
        - MAC destination : 08:00:20:0A:70:66
        - MAC source : 08:00:20:0A:AC:96
        - Type : 08 00 â†’ datagramme IP

        En-tÃªte IP (20 octets) :
        - Version : IPv4, Longueur de lâ€™en-tÃªte : 20 octets
        - Longueur totale : 40 octets
        - Identifiant : A6F5
        - Pas de fragmentation (DF=1, MF=0)
        - TTL : 26
        - Protocole : TCP (06)
        - IP source : 192.92.2.1
        - IP destination : 132.227.61.5
        - Somme de contrÃ´le IP : 7594

        Segment TCP :
        - Port source : 21 (serveur FTP)
        - Port destination : 3975 (client)
        - Flags SYN et ACK activÃ©s â†’ rÃ©ponse positive Ã  la demande de connexion
        - FenÃªtre : 4 096 octets
        - Pas de donnÃ©es, en-tÃªte de 20 octets seulement

        Trame Ethernet complÃ©tÃ©e avec 6 octets de bourrage (20 20 20 20 20 20) pour atteindre 64 octets,
        suivie dâ€™un CRC : 9B 52 46 43.

        **InterprÃ©tation rÃ©seau** : 
        Cette trame peut avoir Ã©tÃ© capturÃ©e :
        - **Dans le rÃ©seau source (192.92.2.0)** : le serveur FTP initie une rÃ©ponse vers le client via un routeur de sortie.
        - **Dans le rÃ©seau destination (132.227.0.0)** : le routeur dâ€™entrÃ©e relaie une rÃ©ponse TCP au client FTP.
        - **Dans un rÃ©seau de transit** : entre routeurs intermÃ©diaires, avec MACs inconnues des machines terminales.

        Il sâ€™agit dâ€™un transfert FTP en cours dâ€™Ã©tablissement de connexion.
actions:
  - action_comparer_protocoles
  - action_expliquer_primitive
  - action_semantic_faq
  - action_set_last_topic
